---
mainImage: ../../../images/part-0.svg
part: 0
letter: b
lang: fr
---

<div class="content">

Avant de commencer la programmation, nous passerons en revue certains principes du dÃ©veloppement Web en examinant un exemple d'application sur <https://studies.cs.helsinki.fi/exampleapp>.

L'application n'existe que pour introduire certains concepts de base du cours et n'est en aucun cas un exemple de <i>comment</i> une application Web moderne doit Ãªtre crÃ©Ã©e.
Au contraire, elle illustre certaines anciennes techniques du dÃ©veloppement Web, qui pourraient mÃªme Ãªtre considÃ©rÃ©es comme de <i>mauvaises pratiques</i> de nos jours.

Le code sera conforme aux bonnes pratiques actuelles Ã  partir de la [partieÂ 1](/fr/part1).

Ouvrez l'[exemple d'application](https://studies.cs.helsinki.fi/exampleapp) dans votre navigateur. Cela peut prendre un certain temps.

**La 1Ã¨re rÃ¨gle du dÃ©veloppement Web**Â : gardez toujours la console de dÃ©veloppement du navigateur ouverte sur votre navigateur Web. Sur macOS, ouvrez la console en appuyant simultanÃ©ment sur _F12_ ou _option-cmd-i_. Sous Windows ou Linux, ouvrez la console en appuyant simultanÃ©ment sur _F12_ ou _ctrl-shift-i_. La console peut Ã©galement Ãªtre ouverte via le [menu contextuel](https://fr.wikipedia.org/wiki/Menu_contextuel).

N'oubliez pas de <i>toujours</i> garder la console ouverte quand vous dÃ©veloppez des applications Web.

La console ressemble Ã  ceci :

![Une capture d'Ã©cran des outils de dÃ©veloppement ouverts dans un navigateur](../../images/0/1e.png)

Assurez-vous que l'onglet <i>RÃ©seau</i> est ouvert et cochez l'option <i>DÃ©sactiver le cache</i> comme indiquÃ©. <i>Conserver le journal</i> peut Ã©galement Ãªtre utileÂ (il enregistre les journaux imprimÃ©s par l'application lorsque la page est rechargÃ©e) ainsi que "Masquer les URL des extensions" (cache les requÃªtes issues d'extensions installÃ©es dans le navigateur, non visibles sur l'image ci-dessus)

**NBÂ :** L'onglet le plus important est l'onglet <i>Console</i>. Cependant, dans cette introduction, nous utiliserons beaucoup l'onglet <i>RÃ©seau</i>.

### HTTP GET

Le serveur et le navigateur Web communiquent entre eux Ã  l'aide du protocole [HTTP](https://developer.mozilla.org/fr/docs/Web/HTTP). L'onglet <i>RÃ©seau</i> montre comment le navigateur et le serveur communiquent.

Lorsque vous rechargez la page (appuyez sur les touches _Fn_-_F5_ sur PC, _cmd_-_R_ sur macOS, ou cliquez sur le symboleÂ &#8635; de votre navigateur), la console indique que deux Ã©vÃ©nements se sont produitsÂ :

- Le navigateur a rÃ©cupÃ©rÃ© le contenu de la page <i>studies.cs.helsinki.fi/exampleapp</i> du serveur
- Et a tÃ©lÃ©chargÃ© l'image <i>kuva.png</i>

![Capture d'Ã©cran de la console dÃ©veloppeur montrant ces deux Ã©vÃ©nements](../../images/0/2e.png)

Sur un petit Ã©cran, vous devrez peut-Ãªtre Ã©largir la fenÃªtre de la console pour le voir.

Cliquer sur le premier Ã©vÃ©nement rÃ©vÃ¨le plus d'informations sur ce qui se passeÂ :

![Vue dÃ©taillÃ©e d'un seul Ã©vÃ©nement](../../images/0/3e.png)

La partie supÃ©rieure, <i>GÃ©nÃ©ral</i>, montre que le navigateur a fait une requÃªte Ã  l'adresse <i><https://studies.cs.helsinki.fi/exampleapp></i> (bien que l'adresse ait lÃ©gÃ¨rement changÃ© depuis que cette photo a Ã©tÃ© prise) en utilisant la mÃ©thode [GET](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/GET), et que la requÃªte a rÃ©ussi, car la rÃ©ponse du serveur avait le [code de statut](https://fr.wikipedia.org/wiki/Liste_des_codes_HTTP) 200.

La requÃªte et la rÃ©ponse du serveur ont plusieurs [en-tÃªtes](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)Â :

![Capture d'Ã©cran des en-tÃªtes de la rÃ©ponse](../../images/0/4e.png)


Les <i>en-tÃªtes de rÃ©ponse</i> en haut nous indiquent par ex. la taille de la rÃ©ponse en octets et l'heure exacte de la rÃ©ponse. Un en-tÃªte important [Content-Type](https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Content-Type) nous indique que la rÃ©ponse est un fichier texte codÃ© en [utf-8](https://fr.wikipedia.org/wiki/UTF-8), dont le contenu a Ã©tÃ© formatÃ© en HTML. De cette faÃ§on, le navigateur sait que la rÃ©ponse est une page [HTML](https://fr.wikipedia.org/wiki/HTML) normale et qu'il doit donc la restituer Ã  l'Ã©cran "comme une page Web".

L'onglet <i>RÃ©ponse</i> affiche les donnÃ©es de rÃ©ponse, une page HTML normale. La section <i>body</i> dÃ©termine la structure de la page rendue Ã  l'Ã©cranÂ :

![Capture d'Ã©cran de l'onglet rÃ©ponse](../../images/0/5e.png)

La page contient un Ã©lÃ©ment [div](https://developer.mozilla.org/fr/docs/Web/HTML/Element/div), qui Ã  son tour contient un titre, un lien vers la page <i>notes </i> et une balise [img](https://developer.mozilla.org/fr/docs/Web/HTML/Element/img) et affiche le nombre de notes crÃ©Ã©es.

En raison de la balise img, le navigateur effectue une seconde <i>requÃªte HTTP</i> pour rÃ©cupÃ©rer l'image <i>kuva.png</i> du serveur. Les dÃ©tails de la demande sont les suivants :

![Vue dÃ©taillÃ©e du deuxiÃ¨me Ã©vÃ©nement](../../images/0/6e.png)

La requÃªte a Ã©tÃ© faite Ã  l'adresse <https://studies.cs.helsinki.fi/exampleapp/kuva.png> et son type est HTTP GET. Les en-tÃªtes de rÃ©ponse nous indiquent que la taille de la rÃ©ponse est de 89350 octets et que son [Content-type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) est <i >image/png</i>, c'est donc une image png. Le navigateur utilise ces informations pour restituer correctement l'image Ã  l'Ã©cran.

La chaÃ®ne d'Ã©vÃ©nements provoquÃ©e par l'ouverture de la page https://studies.cs.helsinki.fi/exampleapp sur un navigateur se prÃ©sente comme suit [diagramme de sÃ©quence](https://www.geeksforgeeks.org/unified-modeling-language-uml-sÃ©quence-diagrammes/):

![SchÃ©ma de sÃ©quence du flux traitÃ© ci-dessus](../../images/0/7e.png)

Tout d'abord, le navigateur envoie une requÃªte HTTP GET au serveur pour rÃ©cupÃ©rer le code HTML de la page. La balise <i>img</i> dans le code HTML invite le navigateur Ã  rÃ©cupÃ©rer l'image <i>kuva.png</i>. Le navigateur affiche la page HTML et l'image Ã  l'Ã©cran.

MÃªme s'il est difficile de s'en apercevoir, la page HTML commence Ã  s'afficher avant que l'image n'ait Ã©tÃ© rÃ©cupÃ©rÃ©e sur le serveur.

### Applications Web traditionnelles

La page d'accueil de d'application d'exemple fonctionne comme une <i>application Web traditionnelle</i>. En entrant dans la page, le navigateur va chercher sur le serveur le document HTML dÃ©taillant la structure et le contenu textuel de la page.

Le serveur a formÃ© ce document d'une maniÃ¨re ou d'une autre. Le document peut Ãªtre un fichier texte <i>statique</i> enregistrÃ© dans le rÃ©pertoire du serveur. Le serveur peut Ã©galement former les documents HTML de maniÃ¨re <i>dynamique</i> selon le code de l'application, en utilisant par exemple les donnÃ©es d'une base de donnÃ©es.
En l'occurence, le code HTML de l'application a Ã©tÃ© formÃ© dynamiquement, car il contient des informations sur le nombre de notes crÃ©Ã©es.

Le code HTML de la page d'accueil est le suivant :

```js
const getFrontPageHtml = (noteCount) => {
  return(`
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Full stack example app</h1>
          <p>number of notes created ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
`)
} 

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})
```
Vous n'avez pas besoin de comprendre ce code, pour le moment.

Le contenu de la page HTML a Ã©tÃ© enregistrÃ© en tant que "littÃ©ral de gabarit" (en anglais, "template string"), c'est Ã  dire une chaÃ®ne de caractÃ¨res qui permet d'Ã©valuer, par exemple, des variables au milieu de celle-ci. La partie dynamique de la page d'accueil, le nombre de notes enregistrÃ©es (dans le code <em>noteCount</em>), est remplacÃ©e par le nombre actuel de notes (dans le code <em>notes.length</em>) dans le gabarit.

Ã‰crire du HTML au milieu du code n'est bien sÃ»r pas trÃ¨s malin, mais pour les programmeurs PHP de la vieille Ã©cole, c'Ã©tait une pratique normale.

Dans les applications Web traditionnelles, le navigateur est "stupide". Il rÃ©cupÃ¨re uniquement les donnÃ©es HTML du serveur et toute la logique d'application se trouve sur le serveur. Un serveur peut Ãªtre crÃ©Ã© en utilisant Java Spring (comme dans le cours de l'UniversitÃ© d'Helsinki [Web-palvelinohjelmointi](https://courses.helsinki.fi/fi/tkt21007/119558639)), Python Flask (comme dans le cours [tietokantasovellus](https://materiaalit.github.io/tsoha-18/)) ou avec [Ruby on Rails](http://rubyonrails.org/) pour ne citer que quelques exemples.

L'exemple utilise [Express](https://expressjs.com/), sur Node.js.
Ce cours utilisera Node.js et Express pour crÃ©er des serveurs Web.

### ExÃ©cution de la logique d'application dans le navigateur

Gardez la Developer Console ouverte. Videz la console en cliquant sur le symbole ğŸš« ou en tapant clear() dans la console.
DÃ©sormais, lorsque vous accÃ©dez Ã  la page [notes](https://studies.cs.helsinki.fi/exampleapp/notes), le navigateur effectue 4Â requÃªtes HTTPÂ :

![Capture d'Ã©cran de la console dÃ©veloppeur avec les 4 requÃªtes visibles](../../images/0/8e.png)

Toutes les demandes ont des types <i>diffÃ©rents</i>. Le type de la premiÃ¨re requÃªte est <i>document</i>. C'est le code HTML de la page, et il se prÃ©sente comme suitÂ :

![Vue dÃ©taillÃ©e de la premiÃ¨re requÃªte](../../images/0/9e.png)

Lorsque l'on compare la page affichÃ©e sur le navigateur et le code HTML renvoyÃ© par le serveur, on remarque que le code ne contient pas la liste des notes.
La section [head](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head) du code HTML contient un [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)-tag, qui amÃ¨ne le navigateur Ã  rÃ©cupÃ©rer un fichier JavaScript appelÃ© <i>main.js</i>.

Le code JavaScript ressemble Ã  ceciÂ :

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementById('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
Les dÃ©tails du code ne sont pas importants pour le moment, mais du code a Ã©tÃ© inclus pour pimenter les images et le texte. Nous commencerons correctement Ã  coder dans la [partieÂ 1](/fr/part1). L'exemple de code de cette partie n'est en fait pas du tout pertinent pour les techniques de codage de ce cours.

> Certains pourraient se demander pourquoi xhttp-object est utilisÃ© Ã  la place du fetch moderne. Cela est dÃ» au fait de ne pas encore du tout vouloir entrer dans les promesses, et le code ayant un rÃ´le secondaire dans cette partie. Nous reviendrons sur les moyens modernes de faire des requÃªtes au serveur dans la partie 2.

ImmÃ©diatement aprÃ¨s avoir rÃ©cupÃ©rÃ© la balise <i>script</i>, le navigateur commence Ã  exÃ©cuter le code.

Les deux derniÃ¨res lignes indiquent au navigateur d'effectuer une requÃªte HTTP GET Ã  l'adresse du serveur <i>/data.json</i>Â :

```js
xhttp.open('GET', '/data.json', true)
xhttp.send()
```
Il s'agit de la derniÃ¨re requÃªte affichÃ©e dans l'onglet RÃ©seau.

Nous pouvons essayer d'aller Ã  l'adresse <https://studies.cs.helsinki.fi/exampleapp/data.json> directement depuis le navigateurÂ :

![](../../images/0/10e.png)

On y retrouve les notes en [JSON](https://en.wikipedia.org/wiki/JSON) "raw data". Par dÃ©faut, les navigateurs basÃ©s sur Chromium ne sont pas trÃ¨s bons pour afficher les donnÃ©es JSON. Des plugins peuvent Ãªtre utilisÃ©s pour gÃ©rer le formatage. Installez, par exemple, [JSONVue](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) sur Chrome, et rechargez la page. Les donnÃ©es sont maintenant bien formatÃ©esÂ :

![Sortie JSON formatÃ©e](../../images/0/11e.png)

Ainsi, le code JavaScript de la page de notes ci-dessus tÃ©lÃ©charge les donnÃ©es JSON contenant les notes et forme une liste Ã  puces Ã  partir du contenu de la noteÂ :

Cela se fait grÃ¢ce au code suivant :

```js
const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)
```
Le code crÃ©e d'abord une liste non ordonnÃ©e avec une balise [ul](https://developer.mozilla.org/fr/docs/Web/HTML/Element/ul)-tag...

```js
var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')
```
... puis ajoute une balise [li](https://developer.mozilla.org/fr/docs/Web/HTML/Element/li) pour chaque note. Seul le champ <i>content</i> (contenu) de chaque note devient le contenu de la balise li. Les horodatages que l'on trouve dans les donnÃ©es brutes ne sont pas utilisÃ©s.

```js
data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```
Ouvrez maintenant l'onglet <i>Console</i> des outils de dÃ©veloppementÂ :


![Capture d'Ã©cran de l'onglet console sur la console dÃ©veloppeur](../../images/0/12e.png)

En cliquant sur le petit triangle au dÃ©but de la ligne, vous pouvez dÃ©velopper le texte sur la console.

![Capture d'Ã©cran de l'une des entrÃ©es prÃ©cÃ©demment rÃ©duites dÃ©veloppÃ©e](../../images/0/13e.png)

Cette sortie sur la console est causÃ©e par la commande <em>console.log</em> dans le codeÂ :

```js
const data = JSON.parse(this.responseText)
console.log(data)
```

Ainsi, aprÃ¨s avoir reÃ§u les donnÃ©es du serveur, le code les imprime sur la console.

L'onglet <i>Console</i> et la commande <em>console.log</em> vous deviendront trÃ¨s familiers pendant le cours. 


### Gestionnaires d'Ã©vÃ©nements et fonctions de rappel (ou "callback")

La structure de ce code est un peu Ã©trange :


```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```
La requÃªte au serveur est envoyÃ©e sur la derniÃ¨re ligne, mais le code pour gÃ©rer la rÃ©ponse se trouve en fait plus haut. Que se passe-t-il?

```js
xhttp.onreadystatechange = function () {
```

Sur cette ligne, un <i>gestionnaire d'Ã©vÃ©nements</i> pour l'Ã©vÃ©nement <i>onreadystatechange</i> est dÃ©fini pour l'objet <em>xhttp</em> effectuant la requÃªte. Lorsque l'Ã©tat de l'objet change, le navigateur appelle la fonction du gestionnaire d'Ã©vÃ©nements. Le code de la fonction vÃ©rifie que [readyState](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState) est Ã©gal Ã  4 (ce qui dÃ©crit la situation <i>L'opÃ©ration est terminÃ©e</i>) et que le code d'Ã©tat HTTP de la rÃ©ponse est 200.


```js
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // code that takes care of the server response
  }
}
```
Ce mÃ©canisme consistant Ã  appeler des gestionnaires d'Ã©vÃ©nements est trÃ¨s courant en JavaScript. Les fonctions de gestionnaire d'Ã©vÃ©nements sont appelÃ©es fonctions [callback](https://developer.mozilla.org/fr/docs/Glossary/Callback_function). Le code d'application n'appelle pas lui-mÃªme les fonctions, mais l'environnement d'exÃ©cution - le navigateur - , appelle la fonction Ã  un moment appropriÃ©, lorsque l'<i>Ã©vÃ©nement</i> s'est produit.

### Document Object Model ou DOM

Nous pouvons considÃ©rer les pages HTML comme des arborescences implicites.

<pre>
html
  head
    link
    script
  body
    div
      h1
      div
        ul
          li
          li
          li
      form
        input
        input
</pre>

La mÃªme structure arborescente peut Ãªtre vue sur l'onglet <i>Ã‰lÃ©ments</i> de la console.

![Une capture d'Ã©cran de l'onglet Ã‰lÃ©ments de la console dÃ©veloppeur](../../images/0/14e.png)

Le fonctionnement du navigateur est basÃ© sur l'idÃ©e de reprÃ©senter les Ã©lÃ©ments HTML sous forme d'arborescence.

Le Document Object Model, ou [DOM](https://fr.wikipedia.org/wiki/Document_Object_Model), est une interface de programmation d'application (<i>API</i>) qui permet la modification par programmation des <i>arborescences d'Ã©lÃ©ments </i> correspondant aux pages Web.

Le code JavaScript introduit dans le chapitre prÃ©cÃ©dent utilisait l'API DOM pour ajouter une liste de notes Ã  la page.

Le code suivant crÃ©e un nouveau noeud pour la variable <em>ul</em> et y ajoute des noeuds enfantsÂ :

```js
var ul = document.createElement('ul')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```
Enfin, la branche d'arborescence de la variable <em>ul</em> est connectÃ©e Ã  sa place dans l'arborescence HTML de toute la pageÂ :

```js
document.getElementById('notes').appendChild(ul)
```

### Manipulation du l'objet document depuis la console

Le noeud le plus haut de l'arborescence DOM d'un document HTML est appelÃ© l'objet <em>document</em>. Nous pouvons effectuer diverses opÃ©rations sur une page Web Ã  l'aide de l'API DOM. Vous pouvez accÃ©der Ã  l'objet <em>document</em> en tapant <em>document</em> dans l'onglet ConsoleÂ :

![](../../images/0/15e.png)

Ajoutons une nouvelle note Ã  la page depuis la console.

Tout d'abord, nous allons obtenir la liste des notes de la page. La liste se trouve dans le premier Ã©lÃ©ment ul de la pageÂ :

```js
list = document.getElementsByTagName('ul')[0]
```

CrÃ©ez ensuite un nouvel Ã©lÃ©ment li et ajoutez-y du contenu textuelÂ :

```js
newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'
```

Et ajoutez le nouvel Ã©lÃ©ment li Ã  la listeÂ :

```js
list.appendChild(newElement)
```

![Capture d'Ã©cran de la page avec la nouvelle note ajoutÃ©e Ã  la liste](../../images/0/16e.png)

MÃªme si la page est mise Ã  jour sur votre navigateur, les modifications ne sont pas permanentes. Si la page est rechargÃ©e, la nouvelle note disparaÃ®tra, car les modifications n'ont pas Ã©tÃ© transmises au serveur. Le code JavaScript que le navigateur rÃ©cupÃ¨re crÃ©era toujours la liste des notes basÃ©es sur les donnÃ©es JSON Ã  partir de l'adresse <https://studies.cs.helsinki.fi/exampleapp/data.json>.

### CSS

L'Ã©lÃ©ment <i>head</i> du code HTML de la page Notes contient une balise [link](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link), qui dÃ©termine que le navigateur doit rÃ©cupÃ©rer une feuille de style [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) Ã  partir de l'adresse [main.css](https://studies.cs.helsinki.fi/exampleapp/main.css).

Les feuilles de style en cascade, ou CSS, sont un langage de feuille de style utilisÃ© pour dÃ©terminer l'apparence des pages Web.

Le fichier CSS rÃ©cupÃ©rÃ© ressemble Ã  ceciÂ : 

```css
.container {
  padding: 10px;
  border: 1px solid; 
}

.notes {
  color: blue;
}
```
Le fichier dÃ©finit deux [sÃ©lecteurs de classe](https://developer.mozilla.org/fr/docs/Web/CSS/Class_selectors). Ceux-ci sont utilisÃ©s pour sÃ©lectionner certaines parties de la page et pour dÃ©finir des rÃ¨gles de style pour les mettre en forme.

Une dÃ©finition de sÃ©lecteur de classe commence toujours par un point et contient le nom de la classe.

Les classes sont des [attributs](https://developer.mozilla.org/fr/docs/Web/HTML/Global_attributes/class), qui peuvent Ãªtre ajoutÃ©s aux Ã©lÃ©ments HTML.

Les attributs CSS peuvent Ãªtre examinÃ©s dans l'onglet <i>Ã©lÃ©ments</i> de la consoleÂ :

![Capture d'Ã©cran de l'onglet Ã‰lÃ©ments sur la console dÃ©veloppeur](../../images/0/17e.png)

L'Ã©lÃ©ment <i>div</i> le plus externe possÃ¨de la classe <i>container</i>. L'Ã©lÃ©ment <i>ul</i> contenant la liste des notes possÃ¨de la classe <i>notes</i>.

La rÃ¨gle CSS dÃ©finit que les Ã©lÃ©ments avec la classe <i>container</i> seront dÃ©limitÃ©s par une [bordure](https://developer.mozilla.org/fr/docs/Web/CSS/border) large d'un pixel. Il dÃ©finit Ã©galement 10 pixels de [padding](https://developer.mozilla.org/fr/docs/Web/CSS/padding) sur l'Ã©lÃ©ment. Cela ajoute un espace vide entre le contenu de l'Ã©lÃ©ment et la bordure.

La deuxiÃ¨me rÃ¨gle CSS dÃ©finit la couleur du texte des notes en bleu.

Les Ã©lÃ©ments HTML peuvent Ã©galement avoir d'autres attributs en dehors des classes. L'Ã©lÃ©ment <i>div</i> contenant les notes a un attribut [id](https://developer.mozilla.org/fr/docs/Web/HTML/Global_attributes/id). Le code JavaScript utilise l'identifiant pour trouver l'Ã©lÃ©ment.

L'onglet <i>Ã‰lÃ©ments</i> de la console peut Ãªtre utilisÃ© pour changer les styles des Ã©lÃ©ments.

![](../../images/0/18e.png)

Les modifications apportÃ©es sur la console ne seront pas permanentes. Si vous souhaitez apporter des modifications durables, elles doivent Ãªtre enregistrÃ©es dans la feuille de style CSS sur le serveur. 

### Chargement d'une page contenant JavaScript - rÃ©vision

Passons en revue ce qui se passe lorsque la page https://studies.cs.helsinki.fi/exampleapp/notes est ouverte sur le navigateur.

![](../../images/0/19e.png)

- Le navigateur va chercher le code HTML dÃ©finissant le contenu et la structure de la page sur le serveur Ã  l'aide d'une requÃªte HTTP GET.
- Les liens dans le code HTML amÃ¨nent le navigateur Ã  rÃ©cupÃ©rer Ã©galement la feuille de style CSS <i>main.css</i>...
- ...et un fichier de code JavaScript <i>main.js</i>
- Le navigateur exÃ©cute le code JavaScript. Le code fait une requÃªte HTTP GET Ã  l'adresse https://studies.cs.helsinki.fi/exampleapp/data.json, qui renvoie les notes sous forme de donnÃ©es JSON.
- Lorsque les donnÃ©es ont Ã©tÃ© rÃ©cupÃ©rÃ©es, le navigateur exÃ©cute un <i>gestionnaire d'Ã©vÃ©nements</i>, qui affiche les notes sur la page Ã  l'aide de l'API DOM. 

### Formulaires et HTTP POST

Examinons maintenant comment l'ajout d'une nouvelle note est effectuÃ©.

La page Notes contient un formulaire dÃ©fini par un [Ã©lÃ©ment <form>](https://developer.mozilla.org/fr/docs/Learn/HTML/Forms/Your_first_HTML_form).

![](../../images/0/20e.png)

Lorsque le bouton du formulaire est cliquÃ©, le navigateur enverra l'entrÃ©e de l'utilisateur au serveur. Ouvrons l'onglet <i>RÃ©seau</i> et voyons Ã  quoi ressemble l'envoi du formulaireÂ :

![Capture d'Ã©cran de l'onglet RÃ©seau oÃ¹ sont affichÃ©s les Ã©vÃ©nements de soumission du formulaire](../../images/0/21e.png)

Ã‰tonnamment, la soumission du formulaire dÃ©clenche pas moins de <i>cinq</i>Â requÃªtes HTTP.
Le premier est l'Ã©vÃ©nement de soumission de formulaire. Zoomons dessus :

![Vue dÃ©taillÃ©e de la premiÃ¨re requÃªte](../../images/0/22e.png)

Il s'agit d'une requÃªte [HTTP POST](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/POST) Ã  l'adresse du serveur <i>new\_note</i>. Le serveur rÃ©pond avec le code d'Ã©tat HTTP 302. Il s'agit d'une [redirection d'URL](https://fr.wikipedia.org/wiki/Redirection_d%27URL), par laquelle le serveur demande au navigateur de faire une nouvelle requÃªte HTTP GET Ã  l'adresse dÃ©finie dans l'en-tÃªte de requÃªte <i>Location</i> - c'est-Ã -dire l'adresse <i>notes</i>.

Ainsi, le navigateur recharge la page Notes. Le rechargement provoque trois requÃªtes HTTP supplÃ©mentairesÂ : la rÃ©cupÃ©ration de la feuille de style (main.css), du code JavaScript (main.js) et des donnÃ©es brutes des notes (data.json).

L'onglet rÃ©seau affiche Ã©galement les donnÃ©es soumises avec le formulaireÂ :

NB: Dans les derniÃ¨res versions de Chrome, les informations sur les donnÃ©es de formulaire se trouvent dans le nouvel onglet "Charge utile" (ou "Payload"), situÃ© Ã  droite de l'onglet En-tÃªtes

![informations sur les donnÃ©es de formulaire](../../images/0/23e.png)

La balise Form a les attributs <i>action</i> et <i>method</i>, qui dÃ©finissent que la soumission du formulaire se fait sous la forme d'une requÃªte HTTP POST Ã  â€‹â€‹l'adresse <i>new_note</i>.

![mise en Ã©vidence de l'action et la mÃ©thode du formulaire](../../images/0/24e.png)

Le code sur le serveur responsable de la requÃªte POST est assez simple (NB : ce code est sur le serveur, et non sur le code JavaScript rÃ©cupÃ©rÃ© par le navigateur) :

```js
app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})
```

Les donnÃ©es sont envoyÃ©es dans le [corps](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/POST) de la requÃªte POST.


Le serveur peut accÃ©der aux donnÃ©es en accÃ©dant au champ <em>req.body</em> de l'objet de requÃªte <em>req</em>.

Le serveur crÃ©e un nouvel objet note et l'ajoute Ã  un tableau appelÃ© <em>notes</em>.

```js
notes.push({
  content: req.body.note,
  date: new Date(),
})
```

Les objets Note ont deux champsÂ : <i>content</i> contenant le contenu proprement dit de la note et <i>date</i> contenant la date et l'heure de crÃ©ation de la note.

Le serveur n'enregistre pas les nouvelles notes dans une base de donnÃ©es, de sorte que les nouvelles notes disparaissent lorsque le serveur est redÃ©marrÃ©.

### AJAX

La page Notes de l'application suit un style de dÃ©veloppement Web du dÃ©but des annÃ©es 90 et utilise "Ajax". Cela fait qu'il est reprÃ©sentatif des sites du dÃ©but des annÃ©es 2000 utilisant des technologies web alors au sommet de leur popularitÃ©.

[AJAX](<https://fr.wikipedia.org/wiki/Ajax_(informatique)>) (JavaScript et XML asynchrones) est un terme introduit en fÃ©vrier 2005 suite aux progrÃ¨s de la technologie des navigateurs pour dÃ©crire une nouvelle approche rÃ©volutionnaire qui permettait de rÃ©cupÃ©rer du contenu sur des pages Web Ã  l'aide de JavaScript inclus dans le code HTML, sans qu'il soit nÃ©cessaire de recharger l'affichage de l'ensemble de la page.

Avant l'Ã¨re AJAX, toutes les pages Web fonctionnaient comme les [applications Web traditionnelles](/fr/part0/introduction_aux_applications_web#applications-web-traditionnelles) que nous avons vues prÃ©cÃ©demment dans ce chapitre.
Toutes les donnÃ©es affichÃ©es sur la page Ã©taient issues du code HTML gÃ©nÃ©rÃ© par le serveur.

La page Notes utilise AJAX pour rÃ©cupÃ©rer les donnÃ©es des notes. La soumission du formulaire utilise toujours le mÃ©canisme traditionnel de soumission de formulaires Web.

Les URL de notre exemple d'application reflÃ¨tent les pratiques d'un temps ancien et insouciant. Les donnÃ©es JSON sont extraites de l'URL <https://studies.cs.helsinki.fi/exampleapp/data.json> et les nouvelles notes sont envoyÃ©es Ã  l'URL <https://studies.cs.helsinki.fi/exampleapp/new_note>.
De nos jours, de telles URL ne seraient pas considÃ©rÃ©es comme acceptables, car elles ne respectent pas les conventions gÃ©nÃ©ralement reconnues des API [REST](https://fr.wikipedia.org/wiki/Representational_state_transfer), que nous Ã©tudierons plus en dÃ©tail dans la [partie 3](/fr/part3)

L'approche appelÃ©e AJAX est maintenant si banale qu'elle est tenue pour acquise. Le terme est tombÃ© dans l'oubli, et la nouvelle gÃ©nÃ©ration n'en a mÃªme pas entendu parler.

### Application Ã  page unique

Dans notre exemple d'application, la page d'accueil fonctionne comme une page Web traditionnelleÂ : toute la logique se trouve sur le serveur et le navigateur affiche uniquement le code HTML conformÃ©ment aux instructions.

La page Notes dÃ©lÃ¨gue au navigateur une partie de la responsabilitÃ© de gÃ©nÃ©rer le code HTML pour les notes existantes. Le navigateur remplit cette tÃ¢che en exÃ©cutant le code JavaScript qu'il a rÃ©cupÃ©rÃ© sur le serveur. Le code rÃ©cupÃ¨re les notes sur le serveur sous forme de donnÃ©es JSON et ajoute des Ã©lÃ©ments HTML pour afficher les notes sur la page Ã  l'aide de [DOM-API](/fr/part0/introduction_aux_applications_web#document-object-model-ou-dom).

Ces derniÃ¨res annÃ©es, le style [application web monopage](https://fr.wikipedia.org/wiki/Application_web_monopage) en anglais SPA (single page application) de crÃ©ation d'applications Web a Ã©mergÃ©. Les sites Web de style SPA ne rÃ©cupÃ¨rent pas diffÃ©rentes pages sur le serveur comme le fait notre exemple d'application, mais ne sont constituÃ©es que d'une seule page HTML extraite du serveur, dont le contenu est manipulÃ© avec du code JavaScript qui s'exÃ©cute dans le navigateur.

La page Notes de notre application ressemble un peu aux applications de style SPA, mais n'en est pas tout Ã  fait une. MÃªme si la logique de rendu des notes est exÃ©cutÃ©e sur le navigateur, la page utilise toujours la mÃ©thode traditionnelle d'ajout de nouvelles notes. Les donnÃ©es sont envoyÃ©es au serveur avec la soumission du formulaire, et le serveur demande au navigateur de recharger la page Notes avec une <i>redirection</i>.

Une version SPA de notre exemple d'application peut Ãªtre trouvÃ©e sur <https://studies.cs.helsinki.fi/exampleapp/spa>.
Ã€ premiÃ¨re vue, l'application ressemble exactement Ã  la prÃ©cÃ©dente.
Le code HTML est presque identique, mais le fichier JavaScript est diffÃ©rent (<i>spa.js</i>) et il y a un petit changement dans la faÃ§on dont la balise <form> est dÃ©finieÂ :

![un formulaire sans action ni mÃ©thode](../../images/0/25e.png)

Le formulaire n'a pas d'attributs <i>action</i> ou <i>method</i> pour dÃ©finir comment et oÃ¹ envoyer les donnÃ©es d'entrÃ©e.

Ouvrez l'onglet <i>RÃ©seau</i> et videz-le. Lorsque vous crÃ©ez maintenant une nouvelle note, vous remarquerez que le navigateur n'envoie qu'une seule requÃªte au serveur.

![L'onglet rÃ©seau ne montrant qu'une seule requÃªte POST vers la SPA new_note](../../images/0/26e.png)

La requÃªte POST Ã  â€‹â€‹l'adresse <i>new\_note\_spa</i> contient la nouvelle note sous forme de donnÃ©es JSON contenant Ã  la fois le contenu de la note (<i>content</i>) et l'horodatage (<i> date</i>)Â :

```js
{
  content: "single page app does not reload the whole page",
  date: "2019-05-25T15:15:59.905Z"
}
```

L'en-tÃªte <i>Content-Type</i> de la requÃªte indique au serveur que les donnÃ©es incluses sont reprÃ©sentÃ©es au format JSON.

![dÃ©tail de l'en-tÃªte Content-type avec la valeur application/json](../../images/0/27e.png)

Sans cet en-tÃªte, le serveur ne saurait pas lire correctement les donnÃ©es.

Le serveur rÃ©pond avec le code d'Ã©tat [201 crÃ©Ã©](https://httpstatuses.com/201). Cette fois, le serveur ne demande pas de redirection, le navigateur reste sur la mÃªme page et n'envoie pas d'autres requÃªtes HTTP.

La version SPA de l'application n'envoie pas les donnÃ©es de formulaire de maniÃ¨re traditionnelle, mais utilise Ã  la place le code JavaScript qu'elle a rÃ©cupÃ©rÃ© sur le serveur.
Nous allons Ã©tudier un peu ce code, mÃªme si en comprendre tous les dÃ©tails n'est pas encore important.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
```

La commande <em>document.getElementById('notes\_form')</em> indique au code de rÃ©cupÃ©rer l'Ã©lÃ©ment de formulaire de la page et d'enregistrer un <i>gestionnaire d'Ã©vÃ©nements</i> pour gÃ©rer l'Ã©vÃ¨nement de soumission du formulaire. Le gestionnaire d'Ã©vÃ©nements appelle immÃ©diatement la mÃ©thode <em>e.preventDefault()</em> pour empÃªcher le comportement par dÃ©faut de la soumission de formulaire. La mÃ©thode par dÃ©faut enverrait les donnÃ©es au serveur et provoquerait une nouvelle requÃªte GET, ce que nous ne voulons pas.

Ensuite, le gestionnaire d'Ã©vÃ©nements crÃ©e une nouvelle note, l'ajoute Ã  la liste des notes avec la commande <em>notes.push(note)</em>, rafraÃ®chit la liste des notes sur la page et envoie la nouvelle note au serveur.

Le code qui permet d'envoyer la note au serveur est le suivantÂ :

```js
var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}
```

Le code dÃ©termine que les donnÃ©es doivent Ãªtre envoyÃ©es avec une requÃªte HTTP POST et que le type de donnÃ©es doit Ãªtre JSON. Le type de donnÃ©es est dÃ©terminÃ© avec un en-tÃªte <i>Content-type</i>. Ensuite, les donnÃ©es sont envoyÃ©es sous forme de chaÃ®ne JSON.

Le code d'application est disponible sur <https://github.com/mluukkai/example_app>.
Il convient de rappeler que l'application est uniquement destinÃ©e Ã  dÃ©montrer les concepts du cours. Son code suit un style de dÃ©veloppement mÃ©diocre par bien des aspects et ne doit pas Ãªtre utilisÃ© comme exemple lors de la crÃ©ation de vos propres applications. Il en va de mÃªme pour les URL utilisÃ©es. L'URL <i>new\_note\_spa</i>, Ã  laquelle les nouvelles notes sont envoyÃ©es, ne respecte pas les meilleures pratiques actuelles.

### BibliothÃ¨ques JavaScript

L'exemple d'application est rÃ©alisÃ© avec ce qu'on appelle [vanilla JavaScript](https://www.freecodecamp.org/news/is-vanilla-javascript-worth-learning-absolutely-c2c67140ac34/), en utilisant uniquement l'API DOM et des fonctions standard de JavaScript pour manipuler la structure des pages.

Au lieu d'utiliser uniquement JavaScript et l'API DOM, diffÃ©rentes bibliothÃ¨ques contenant des outils plus faciles Ã  utiliser que l'API DOM sont souvent utilisÃ©es pour manipuler les pages. L'une de ces bibliothÃ¨ques est la trÃ¨s populaire [jQuery](https://jquery.com/).

jQuery a Ã©tÃ© dÃ©veloppÃ© Ã  l'Ã©poque oÃ¹ les applications Web suivaient principalement le style traditionnel du serveur gÃ©nÃ©rant des pages HTML, dont la fonctionnalitÃ© Ã©tait amÃ©liorÃ©e du cÃ´tÃ© du navigateur Ã  l'aide de JavaScript Ã©crit avec jQuery. L'une des raisons du succÃ¨s de jQuery Ã©tait sa compatibilitÃ© revendiquÃ©e entre navigateurs. La bibliothÃ¨que fonctionnait quel que soit le navigateur ou la sociÃ©tÃ© qui l'avait crÃ©Ã©e, il n'y avait donc pas besoin de solutions spÃ©cifiques par navigateur. De nos jours, l'utilisation de jQuery n'est plus aussi justifiÃ©e compte tenu de l'avancement de JavaScript, et les navigateurs les plus populaires supportent gÃ©nÃ©ralement bien les fonctionnalitÃ©s de base.

L'essor des applications Ã  page unique a engendrÃ© des mÃ©thodes de dÃ©veloppement Web plus "modernes" que jQuery. Le favori d'une premiÃ¨re vague de dÃ©veloppeurs Ã©tait [BackboneJS](http://'backbonejs.org/). AprÃ¨s son [lancement](https://github.com/angular/angular.js/blob/master/CHANGELOG.md#100-temporal-domination-2012-06-13) en 2012, Google [AngularJS](https: //angularjs.org/) est rapidement devenu une quasi norme de facto du dÃ©veloppement Web moderne.

Cependant, la popularitÃ© d'Angular a chutÃ© en octobre 2014 aprÃ¨s que [l'Ã©quipe d'Angular a annoncÃ© que le support de la version 1 prendrait fin](https://jaxenter.com/angular-2-0-announcement-backfires-112127.html), et qu'Angular 2 ne serait pas rÃ©trocompatible avec la premiÃ¨re version. Angular 2 et les versions plus rÃ©centes n'ont pas Ã©tÃ© accueillies trÃ¨s chaleureusement.

Actuellement, l'outil le plus populaire pour implÃ©menter la logique cÃ´tÃ© navigateur des applications Web est la bibliothÃ¨que [React](https://reactjs.org/) de Facebook.
Au cours de ce cours, nous nous familiariserons avec React et la bibliothÃ¨que [Redux](https://github.com/reactjs/redux), qui sont frÃ©quemment utilisÃ©es ensemble.

La position de React semble aujourd'hui dominante, mais le monde de JavaScript est en constante Ã©volution. Par exemple, rÃ©cemment, un nouveau venu - [VueJS](https://vuejs.org/) - a suscitÃ© un intÃ©rÃªt certain.

###Â DÃ©veloppement Web Full Stack

Que signifie le nom du cours, <i>DÃ©veloppement Web Full Stack</i>Â ? Le full stack est un mot Ã  la mode dont tout le monde parle, alors que personne ne sait vraiment ce que cela signifie. Ou du moins, il n'y a pas de dÃ©finition convenue pour le terme.

Preque toutes les applications Web ont (au moins) deux "couches": le navigateur, Ã©tant plus proche de l'utilisateur final, est la couche supÃ©rieure et le serveur contitue la couche infÃ©rieure. Il y a souvent aussi une couche de base de donnÃ©es sous le serveur. On peut donc penser Ã  l'<i>architecture</i> d'une application web comme une sorte de <i>pile (stack)</i> de couches.

Souvent, on parle aussi du [frontend et du backend](https://en.wikipedia.org/wiki/Front_and_back_ends). Le navigateur est le frontend, la partie client, et le code JavaScript qui s'exÃ©cute sur le navigateur est le code de la partie client. Le serveur, quant Ã  lui, est le backend.

Dans le cadre de ce cours, le dÃ©veloppement web full stack signifie que nous nous concentrons sur toutes les parties de l'application : le frontend, le backend et la base de donnÃ©es. Parfois, le logiciel sur le serveur et son systÃ¨me d'exploitation sont considÃ©rÃ©s comme une partie distincte de l'application, mais nous ne les aborderons pas dans ici.

Nous allons coder le backend avec JavaScript, en utilisant l'environnement d'exÃ©cution [Node.js](https://nodejs.org/en/). L'utilisation du mÃªme langage de programmation pour le backend et le frontend confÃ¨re au dÃ©veloppement d'une application web complÃ¨te une toute nouvelle dimension. Cependant, il n'est pas obligatoire pour le dÃ©veloppement Web "full-stack" d'utiliser le mÃªme langage de programmation (JavaScript) pour toutes les parties de  l'application.

Auparavant, il Ã©tait plus courant pour les dÃ©veloppeurs de se spÃ©cialiser dans une de ses parties, par exemple le backend. Les technologies sur le backend et le frontend Ã©taient assez diffÃ©rentes. Avec la tendance Full stack, il est devenu courant pour les dÃ©veloppeurs de maÃ®triser toutes les couches de l'application et de la base de donnÃ©es. Souvent, les dÃ©veloppeurs full stack doivent Ã©galement avoir suffisamment de compÃ©tences en configuration et en administration pour faire fonctionner leur application, par exemple dans le cloud.

### Fatigue JavaScript

Le dÃ©veloppement Web est difficile Ã  bien des Ã©gards. Les choses se passent dans plusieurs endroits Ã  la fois, et le dÃ©bogage est un peu plus difficile qu'avec les applications de bureau classiques. JavaScript ne fonctionne pas toujours comme prÃ©vu (par rapport Ã  de nombreux autres langages), et le fonctionnement asynchrone de ses environnements d'exÃ©cution entraÃ®ne toutes sortes de dÃ©fis. Communiquer sur le web nÃ©cessite la connaissance du protocole HTTP. Il faut Ã©galement gÃ©rer les bases de donnÃ©es et l'administration et la configuration des serveurs. Il serait Ã©galement bon de connaÃ®tre suffisamment de CSS pour rendre les applications au moins quelque peu prÃ©sentables.

Le monde de JavaScript se dÃ©veloppe rapidement, ce qui apporte son lot de dÃ©fis. Les outils, les bibliothÃ¨ques et le langage lui-mÃªme sont en constante Ã©volution. Certains commencent Ã  en avoir assez du changement constant et ont inventÃ© un terme pour celaÂ : <em>fatigue JavaScript</em>. Voir [How to Manage JavaScript Fatigue on auth0](https://auth0.com/blog/how-to-manage-javascript-fatigue/) ou [JavaScript fatigue on Medium](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4).

Vous souffrirez vous-mÃªme de JavaScript fatigue pendant ce cours. Heureusement pour nous, il existe plusieurs faÃ§ons de lisser la courbe d'apprentissage, et nous pouvons commencer par le codage au lieu de la configuration. Nous ne pouvons pas complÃ¨tement Ã©viter la configuration, mais nous pouvons joyeusement aller de l'avant dans les prochaines semaines tout en Ã©vitant pourl'instant l'exploration des enfers de la configuration. 

</div>

<div class="tasks"> 
  <h3>Exercices 0.1.-0.6.</h3>

Les exercices doivent Ãªtre soumis via GitHub, et en marquant les exercices comme effectuÃ©s dans le [systÃ¨me de soumission](https://studies.cs.helsinki.fi/stats/courses/fullstackopen).

Vous pouvez soumettre tous les exercices dans le mÃªme dÃ©pÃ´t ou utiliser plusieurs dÃ©pÃ´ts diffÃ©rents. Si vous soumettez des exercices de diffÃ©rentes parties dans le mÃªme dÃ©pÃ´t, nommez bien vos rÃ©pertoires. Si vous utilisez un dÃ©pÃ´t privÃ© pour soumettre les exercices, ajoutez-y _mluukkai_ en tant que collaborateur.

Une bonne faÃ§on de nommer les rÃ©pertoires de votre dÃ©pÃ´t de soumission est la suivanteÂ :

```
part0
part1
  courseinfo
  unicafe
  anecdotes
part2
  courseinfo
  phonebook
  countries
```

Ainsi, chaque partie a son propre rÃ©pertoire, qui contient un rÃ©pertoire pour chaque ensemble d'exercices (comme les exercices unicafÃ© de la partie 1).

Les exercices sont soumis **une partie Ã  la fois**. Lorsque vous avez soumis les exercices d'une partie, vous ne pouvez plus soumettre d'exercices manquÃ©s pour cette partie.

  <h4>0.1: HTML</h4>

Passez en revue les bases du HTML en lisant ce didacticiel de MozillaÂ : [tutoriel HTML](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

  <h4>0.2: CSS</h4>

Passez en revue les bases de CSS en lisant ce tutoriel de MozillaÂ : [tutoriel CSS](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

   <h4>0.3Â : Formulaires HTML</h4>

DÃ©couvrez les bases des formulaires HTML en lisant le didacticiel de Mozilla [Votre premier formulaire](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Your_first_HTML_form).

<i>Cet exercice n'est pas soumis Ã  GitHub, il suffit de lire le tutoriel</i>

  <h4>0.4Â : Nouvelle note</h4>

Dans le chapitre [Chargement d'une page contenant JavaScript - rÃ©vision](/fr/part0/introduction_aux_applications_web#chargement-dune-page-contenant-java-script-revision) la chaÃ®ne d'Ã©vÃ©nements causÃ©s par l'ouverture de la page https://studies.cs.helsinki.fi/exampleapp/notes est reprÃ©sentÃ©e comme un [diagramme de sÃ©quence](https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/)

Le diagramme est en rÃ©alitÃ© un fichier Markdown de gitHub qui a Ã©tÃ© crÃ©Ã© Ã  l'aide de la syntaxe [Mermaid](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams) comme suitÂ :

```text
sequenceDiagram
    participant browser
    participant server

    browser->>server: GET https://studies.cs.helsinki.fi/exampleapp/notes
    activate server
    server-->>browser: HTML document
    deactivate server

    browser->>server: GET https://studies.cs.helsinki.fi/exampleapp/main.css
    activate server
    server-->>browser: the css file
    deactivate server

    browser->>server: GET https://studies.cs.helsinki.fi/exampleapp/main.js
    activate server
    server-->>browser: the JavaScript file
    deactivate server

    Note right of browser: The browser starts executing the JavaScript code that fetches the JSON from the server

    browser->>server: GET https://studies.cs.helsinki.fi/exampleapp/data.json
    activate server
    server-->>browser: [{ "content": "HTML is easy", "date": "2023-1-1" }, ... ]
    deactivate server

    Note right of browser: The browser executes the callback function that renders the notes
```

**CrÃ©ez un diagramme similaire** illustrant ce qu'il se passe quand l'utilisateur crÃ©e une nouvelle note sur la page <https://studies.cs.helsinki.fi/exampleapp/notes> en Ã©crivant quelque chose dans le champ de texte et en cliquant sur le <i> bouton envoyer</i>.

Si nÃ©cessaire, affichez les opÃ©rations sur le navigateur ou sur le serveur sous forme de commentaires sur le diagramme.

Le diagramme ne doit pas nÃ©cessairement Ãªtre un diagramme de sÃ©quence. Toute maniÃ¨re sensÃ©e de prÃ©senter les Ã©vÃ©nements est acceptable.

Toutes les informations nÃ©cessaires pour ce faire, ainsi que les deux exercices suivants, se trouvent dans le texte de [cette partie](/fr/part0/introduction_aux_applications_web#formulaires-et-http-post).
L'idÃ©e de ces exercices est de lire le texte une fois de plus et de rÃ©flÃ©chir Ã  ce qui s'y passe. La lecture de l'application [code](https://github.com/mluukkai/example_app) n'est pas nÃ©cessaire, mais est bien sÃ»r possible.

Vous pouvez rÃ©aliser le diagramme Ã  l'aide de n'importe quel programme, mais le moyen le plus simple est peut-Ãªtre la syntaxe  [Mermaid](https://github.com/mermaid-js/mermaid#sequence-diagram-docs---live-editor) qui est maintenant implÃ©mentÃ©e dans les pages Markdown de [GitHub](https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/) !

  <h4>0.5Â :Â Application Ã  page unique</h4>

CrÃ©ez un diagramme illustrant la situation dans laquelle l'utilisateur accÃ¨de Ã  la version [application Ã  page unique](/fr/part0/introduction_aux_applications_web#application-a-page-unique) de l'application de notes sur <https://studies.cs.helsinki.fi/exampleapp/spa>.

  <h4>0.6Â : Nouvelle note</h4>

CrÃ©ez un diagramme illustrant la situation dans laquelle l'utilisateur crÃ©e une nouvelle note Ã  l'aide de la version Ã  page unique de l'application.

C'Ã©tait le dernier exercice, et il est temps de transmettre vos rÃ©ponses Ã  GitHub et de marquer les exercices comme effectuÃ©s dans le [systÃ¨me de soumission](https://studies.cs.helsinki.fi/stats/courses/fullstackopen).
</div>
