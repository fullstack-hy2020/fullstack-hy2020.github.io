{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part12/basics_of_orchestration","result":{"data":{"markdownRemark":{"html":"<div class=\"tasks\">\n<p>The part was updated 21th Mar 2024: Create react app was replaced with Vite in the todo-frontend.</p>\n<p>If you started the part before the update, you can see <a href=\"https://github.com/fullstack-hy2020/fullstack-hy2020.github.io/tree/4015af9dddb61cb01f013456d8728e8f553be347/src/content/12\">here</a> the old material. There are some changes in the frontend configurations.</p>\n</div>\n<div class=\"content\">\n<p>We have now a basic understanding of Docker and can use it to easily set up eg. a database for our app. Let us now move our focus to the frontend. </p>\n<h3>React in container</h3>\n<p>Let's create and containerize a React application next. We start with the usual steps:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> create vite@latest hello-front -- <span class=\"token parameter variable\">--template</span> react\n$ <span class=\"token builtin class-name\">cd</span> hello-front\n$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span></code></pre></div>\n<p>The next step is to turn the JavaScript code and CSS, into production-ready static files. Vite already has <em>build</em> as an npm script so let's use that:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> run build\n  <span class=\"token punctuation\">..</span>.\n\n  Creating an optimized production build<span class=\"token punctuation\">..</span>.\n  <span class=\"token punctuation\">..</span>.\n  The build folder is ready to be deployed.\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Great! The final step is figuring out a way to use a server to serve the static files. As you may know, we could use <a href=\"https://expressjs.com/en/starter/static-files.html\">express.static</a> with the Express server to serve the static files. I'll leave that as an exercise for you to do at home. Instead, we are going to go ahead and start writing our Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span></code></pre></div>\n<p>That looks about right. Let's build it and see if we are on the right track. Our goal is to have the build succeed without errors. Then we will use bash to check inside of the container to see if the files are there.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> build <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-t</span> hello-front\n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span>/5<span class=\"token punctuation\">]</span> RUN <span class=\"token function\">npm</span> ci                  \n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span>/5<span class=\"token punctuation\">]</span> RUN <span class=\"token function\">npm</span> run \n <span class=\"token punctuation\">..</span>.             \n <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> naming to docker.io/library/hello-front\n\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-front <span class=\"token function\">bash</span>\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls</span>\n  Dockerfile  README.md  dist  index.html  node_modules  package-lock.json  package.json\tpublic\tsrc  vite.config.js\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls dist</span>\n  assets\tindex.html  vite.svg</code></pre></div>\n<p>A valid option for serving static files now that we already have Node in the container is <a href=\"https://www.npmjs.com/package/serve\">serve</a>. Let's try installing serve and serving the static files while we are inside the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@98fa9483ee85:/usr/src/app<span class=\"token comment\"># npm install -g serve</span>\n\n  added <span class=\"token number\">89</span> packages <span class=\"token keyword\">in</span> 2s\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># serve dist</span>\n\n   ┌────────────────────────────────────────┐\n   │                                        │\n   │   Serving<span class=\"token operator\">!</span>                             │\n   │                                        │\n   │   - Local:    http://localhost:3000    │\n   │   - Network:  http://172.17.0.2:3000   │\n   │                                        │\n   └────────────────────────────────────────┘</code></pre></div>\n<p>Great! Let's ctrl+c to exit out and then add those to our Dockerfile.</p>\n<p>The installation of serve turns into a RUN in the Dockerfile. This way the dependency is installed during the build process. The command to serve the <i>dist</i> directory will become the command to start the container:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install -g serve</span></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"serve\"</span>, <span class=\"token string\">\"dist\"</span>]</span></span></code></pre></div>\n<p>Our CMD now includes square brackets and as a result, we now use the <i>exec form</i> of CMD. There are actually <strong>three</strong> different forms for CMD, out of which the exec form is preferred. Read the <a href=\"https://docs.docker.com/reference/dockerfile/#cmd\">documentation</a> for more info.</p>\n<p>When we now build the image with <em>docker build . -t hello-front</em> and run it with <em>docker run -p 5001:3000 hello-front</em>, the app will be available in <a href=\"http://localhost:5001\">http://localhost:5001</a>.</p>\n<h3>Using multiple stages</h3>\n<p>While serve is a <i>valid</i> option, we can do better. A good goal is to create Docker images so that they do not contain anything irrelevant. With a minimal number of dependencies, images are less likely to break or become vulnerable over time.</p>\n<p><a href=\"https://docs.docker.com/build/building/multi-stage/\">Multi-stage builds</a> are designed to split the build process into many separate stages, where it is possible to limit what parts of the image files are moved between the stages. That opens possibilities for limiting the size of the image since not all the by-products of the build are necessary for the resulting image. Smaller images are faster to upload and download and they help reduce the number of vulnerabilities that your software may have.</p>\n<p>With multi-stage builds, a tried and true solution like <a href=\"https://en.wikipedia.org/wiki/Nginx\">Nginx</a> can be used to serve static files without a lot of headaches. The Docker Hub <a href=\"https://hub.docker.com/_/nginx\">page for Nginx</a> tells us the required info to open the ports and \"Hosting some simple static content\".</p>\n<p>Let's use the previous Dockerfile but change the FROM to include the name of the stage:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># The first FROM is now a stage called build-stage</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20 <span class=\"token keyword\">AS</span> build-stage </span></span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"token comment\"># This is a new stage, everything before this is gone, except for the files that we want to COPY</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> nginx:1.25-alpine</span></span>\n<span class=\"token comment\"># COPY the directory dist from the build-stage to /usr/share/nginx/html</span>\n<span class=\"token comment\"># The target location here was found from the Docker hub page</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build-stage</span></span> /usr/src/app/dist /usr/share/nginx/html</span></span></code></pre></div>\n<p>We have also declared <i>another stage</i>, where only the relevant files of the first stage (the <i>dist</i> directory, that contains the static content) are copied.</p>\n<p>After we build it again, the image is ready to serve the static content. The default port will be 80 for Nginx, so something like <em>-p 8000:80</em> will work, so the parameters of the RUN command need to be changed a bit.</p>\n<p>Multi-stage builds also include some internal optimizations that may affect your builds. As an example, multi-stage builds skip stages that are not used. If we wish to use a stage to replace a part of a build pipeline, like testing or notifications, we must pass <strong>some</strong> data to the following stages. In some cases this is justified: copy the code from the testing stage to the build stage. This ensures that you are building the tested code.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.13 - 12.14.</h3>\n<h4>Exercise 12.13: Todo application frontend</h4>\n<p>Finally, we get to the todo-frontend. View the todo-app/todo-frontend and read through the README.</p>\n<p>Start by running the frontend outside the container and ensure that it works with the backend.</p>\n<p>Containerize the application by creating <i>todo-app/todo-frontend/Dockerfile</i> and use the <a href=\"https://docs.docker.com/engine/reference/builder/#env\">ENV</a> instruction to pass <em>VITE_BACKEND_URL</em> to the application and run it with the backend. The backend should still be running outside a container. </p>\n<p><strong>Note</strong> that you need to set <em>VITE_BACKEND_URL</em> before building the frontend, otherwise, it does not get defined in the code!</p>\n<h4>Exercise 12.14: Testing during the build process</h4>\n<p>One interesting possibility that utilizing multi-stage builds gives us, is to use a separate build stage for <a href=\"https://docs.docker.com/language/nodejs/run-tests/\">testing</a>. If the testing stage fails, the whole build process will also fail. Note that it may not be the best idea to move <i>all testing</i> to be done during the building of an image, but there may be <i>some</i> containerization-related tests where it might be worth considering. </p>\n<p>Extract a component <i>Todo</i> that represents a single todo. Write a test for the new component and add running the tests into the build process.</p>\n<p>You can add a new build stage for the test if you wish to do so. If you do so, remember to read the last paragraph before exercise 12.13 again!</p>\n</div>\n<div class=\"content\">\n<h3>Development in containers</h3>\n<p>Let's move the whole todo application development to a container. There are a few reasons why you would want to do that:</p>\n<ul>\n<li>To keep the environment similar between development and production to avoid bugs that appear only in the production environment</li>\n<li>To avoid differences between developers and their personal environments that lead to difficulties in application development</li>\n<li>To help new team members hop in by having them install container runtime - and requiring nothing else.</li>\n</ul>\n<p>These all are great reasons. The tradeoff is that we may encounter some unconventional behavior when we aren't running the applications like we are used to. We will need to do at least two things to move the application to a container:</p>\n<ul>\n<li>Start the application in development mode</li>\n<li>Access the files with VS Code</li>\n</ul>\n<p>Let's start with the frontend. Since the Dockerfile will be significantly different from the production Dockerfile let's create a new one called <i>dev.Dockerfile</i>.</p>\n<p><strong>Note</strong> we shall use the name <i>dev.Dockerfile</i> for development configurations and <i>Dockerfile</i> otherwise.</p>\n<p>Starting Vite in development mode should be easy. Let's start with the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token comment\"># Change npm ci to npm install since we are going to be in development mode</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install</span>\n\n<span class=\"token comment\"># npm run dev is the command to start the application in development mode</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"npm\"</span>, <span class=\"token string\">\"run\"</span>, <span class=\"token string\">\"dev\"</span>, <span class=\"token string\">\"--\"</span>, <span class=\"token string\">\"--host\"</span>]</span></code></pre></div>\n<blockquote>\n<p>Note the extra parameters <em>-- --host</em> in the <em>CMD</em>. Those are needed to expose the development server to be visible outside the Docker network. By default the development server is exposed only to localhost, and despite we access the frontend still using the localhost address, it is in reality attached to the Docker network.</p>\n</blockquote>\n<p>During build the flag <em>-f</em> will be used to tell which file to use, it would otherwise default to Dockerfile, so the following command will build the image:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-f</span> ./dev.Dockerfile <span class=\"token parameter variable\">-t</span> hello-front-dev <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>Vite will be served in port 5173, so you can test that it works by running a container with that port published.</p>\n<p>The second task, accessing the files with VSCode, is not yet taken care of. There are at least two ways of doing this: </p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/docs/remote/containers\">The Visual Studio Code Remote - Containers extension</a> </li>\n<li>Volumes, the same thing we used to preserve data with the database</li>\n</ul>\n<p>Let's go over the latter since that will work with other editors as well. Let's do a trial run with the flag <em>-v</em>, and if that works, then we will move the configuration to a docker-compose file. To use the <em>-v</em>, we will need to tell it the current directory. The command <em>pwd</em> should output the path to the current directory for us. Let's try this with <em>echo $(pwd)</em> in the command line. We can use that as the left side for <em>-v</em> to map the current directory to the inside of the container or we can use the full directory path.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">5173</span>:5173 <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/usr/src/app/\"</span> hello-front-dev\n<span class=\"token operator\">></span> todo-vite@0.0.0 dev\n<span class=\"token operator\">></span> vite <span class=\"token parameter variable\">--host</span>\n\n  VITE v5.1.6  ready <span class=\"token keyword\">in</span> <span class=\"token number\">130</span> ms</code></pre></div>\n<p>Now we can edit the file <i>src/App.jsx</i>, and the changes should be hot-loaded to the browser!</p>\n<p>If you have a Mac with M1/M2 processor, the above command fails. In the error message, we notice the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error: Cannot find module @rollup/rollup-linux-arm64-gnu</code></pre></div>\n<p>The problem is the library <a href=\"https://www.npmjs.com/package/rollup\">rollup</a> that has its own version for all operating systems and processor architectures. Due to the volume mapping, the container is now using the <em>node_modules</em> from the host machine directory where the <em>@rollup/rollup-darwin-arm64</em> (the version suitable Mac M1/M2) is installed, so the right version of the library for the container <em>@rollup/rollup-linux-arm64-gnu</em> is not found.</p>\n<p>There are several ways to fix the problem. Let's use the perhaps simplest one. Start the container with bash as the command, and run the <em>npm install</em> inside the container:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/usr/src/app/\"</span> front-dev <span class=\"token function\">bash</span>\nroot@b83e9040b91d:/usr/src/app<span class=\"token comment\"># npm install</span></code></pre></div>\n<p>Now both versions of the library rollup are installed and the container works!  </p>\n<p>Next, let's move the config to the file <i>docker-compose.dev.yml</i>. This file should be at the root of the project as well:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> . <span class=\"token comment\"># The context will pick this directory as the \"build context\"</span>\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile <span class=\"token comment\"># This will simply tell which dockerfile to read</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app <span class=\"token comment\"># The path can be relative, so ./ is enough to say \"the same location as the docker-compose.yml\"</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev <span class=\"token comment\"># This will name the container hello-front-dev</span></code></pre></div>\n<p>With this configuration, <em>docker compose -f docker-compose.dev.yml up</em> can run the application in development mode. You don't even need Node installed to develop it!</p>\n<p><strong>Note</strong> we shall use the name <i>docker-compose.dev.yml</i> for development environment compose files, and the default name <i>docker-compose.yml</i> otherwise.</p>\n<p>Installing new dependencies is a headache for a development setup like this. One of the better options is to install the new dependency <strong>inside</strong> the container. So instead of doing e.g. <em>npm install axios</em>, you have to do it in the running container e.g. <em>docker exec hello-front-dev npm install axios</em>, or add it to the package.json and run <em>docker build</em> again.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.15</h3>\n<h4>Exercise 12.15: Set up a frontend development environment</h4>\n<p>Create <i>todo-frontend/docker-compose.dev.yml</i> and use volumes to enable the development of the todo-frontend while it is running <i>inside</i> a container.</p>\n</div>\n<div class=\"content\">\n<h3>Communication between containers in a Docker network</h3>\n<p>The Docker Compose tool sets up a network between the containers and includes a DNS to easily connect two containers. Let's add a new service to the Docker Compose and we shall see how the network and DNS work.</p>\n<p><a href=\"https://www.busybox.net/\">Busybox</a> is a small executable with multiple tools that you may need. It is called \"The Swiss Army Knife of Embedded Linux\", and we definitely can use it to our advantage.</p>\n<p>Busybox can help us to debug our configurations. So if you get lost in the later exercises of this section, you should use Busybox to find out what works and what doesn't. Let's use it to explore what was just said. That the containers are inside a network and you can easily connect between them. Busybox can be added to the mix by changing <i>docker-compose.dev.yml</i> to:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</span></code></pre></div>\n<p>The Busybox container won't have any process running inside so we can not <em>exec</em> in there. Because of that, the output of <em>docker compose up</em> will also look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up                                                                                    <span class=\"token number\">0</span>.0s\nAttaching to front-dev, debug-helper-1\ndebug-helper-1 exited with code <span class=\"token number\">0</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span> <span class=\"token operator\">></span> todo-vite@0.0.0 dev\nfront-dev       <span class=\"token operator\">|</span> <span class=\"token operator\">></span> vite <span class=\"token parameter variable\">--host</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span>\nfront-dev       <span class=\"token operator\">|</span>   VITE v5.2.2  ready <span class=\"token keyword\">in</span> <span class=\"token number\">153</span> ms</code></pre></div>\n<p>This is expected as it's just a toolbox. Let's use it to send a request to hello-front-dev and see how the DNS works. While the hello-front-dev is running, we can do the request with <a href=\"https://en.wikipedia.org/wiki/Wget\">wget</a> since it's a tool included in Busybox to send a request from the debug-helper to hello-front-dev.</p>\n<p>With Docker Compose we can use <em>docker compose run SERVICE COMMAND</em> to run a service with a specific command. Command wget requires the flag <em>-O</em> with <em>-</em> to output the response to the stdout:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml run debug-helper <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> - http://app:5173\n\nConnecting to app:5173 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.240.3:5173<span class=\"token punctuation\">)</span>\nwriting to stdout\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>doctype html<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>html <span class=\"token assign-left variable\">lang</span><span class=\"token operator\">=</span><span class=\"token string\">\"en\"</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>script <span class=\"token assign-left variable\">type</span><span class=\"token operator\">=</span><span class=\"token string\">\"module\"</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>The URL is the interesting part here. We simply said to connect to port 5173 of the service <i>app</i>. <i>app</i> is the name of the service specified in the <i>docker-compose.dev.yml</i> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span></span>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> 5173<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span></span>    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev</code></pre></div>\n<p>The port used is the port from which the application is available in that container, also specified in the <i>docker-compose.dev.yml</i>. The port does not need to be published for other services in the same network to be able to connect to it. The \"ports\" in the docker-compose file are only for external access.</p>\n<p>Let's change the port configuration in the <i>docker-compose.dev.yml</i> to emphasize this:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> 3210<span class=\"token punctuation\">:</span><span class=\"token number\">5173</span></span>    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</code></pre></div>\n<p>With <em>docker compose up</em> the application is available in <a href=\"http://localhost:3210\">http://localhost:3210</a> at the <i>host machine</i>, but the command </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose  <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml run debug-helper <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> - http://app:5173</code></pre></div>\n<p>works still since the port is still 5173 within the docker network.</p>\n<p>The below image illustrates what happens. The command <em>docker compose run</em> asks debug-helper to send the request within the network. While the browser in the host machine sends the request from outside of the network.</p>\n<picture><img src=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png\" srcset=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/772e8/busybox_networking_drawio.png 200w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/e17e5/busybox_networking_drawio.png 400w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png 441w\" sizes=\"(max-width: 441px) 100vw, 441px\"></picture>\n<p>Now that you know how easy it is to find other services in the <i>docker-compose.yml</i> and we have nothing to debug we can remove the debug-helper and revert the ports to 5173:5173 in our compose file.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.16</h3>\n<h4>Exercise 12.16: Run todo-backend in a development container</h4>\n<p>Use volumes and Nodemon to enable the development of the todo app backend while it is running <i>inside</i> a container. Create a <i>todo-backend/dev.Dockerfile</i> and edit the <i>todo-backend/docker-compose.dev.yml</i>.</p>\n<p>You will also need to rethink the connections between backend and MongoDB / Redis. Thankfully Docker Compose can include environment variables that will be passed to the application:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n      <span class=\"token punctuation\">-</span> REDIS_URL=redisurl_here\n      <span class=\"token punctuation\">-</span> MONGO_URL=mongourl_here</code></pre></div>\n<p>The URLs are purposefully wrong, you will need to set the correct values. Remember to <i>look all the time what happens in the console</i>. If and when things blow up, the error messages hint at what might be broken.</p>\n<p>Here is a possibly helpful image illustrating the connections within the docker network:</p>\n<picture><img src=\"/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png\" alt=\"diagram of connection between browser, backend, mongo and redis\" srcset=\"/static/e866965c916d7f8e5a8515d3aa16bc44/772e8/ex_12_15_backend_drawio.png 200w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/e17e5/ex_12_15_backend_drawio.png 400w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png 467w\" sizes=\"(max-width: 467px) 100vw, 467px\"></picture>\n</div>\n<div class=\"content\">\n<h3>Communications between containers in a more ambitious environment</h3>\n<p>Next, we will configure a <a href=\"https://en.wikipedia.org/wiki/Reverse_proxy\">reverse proxy</a> to our docker-compose.dev.yml. According to wikipedia</p>\n<blockquote>\n<p><i>A reverse proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client, appearing as if they originated from the reverse proxy server itself.</i></p>\n</blockquote>\n<p>So in our case, the reverse proxy will be the single point of entry to our application, and the final goal will be to set both the React frontend and the Express backend behind the reverse proxy. </p>\n<p>There are multiple different options for a reverse proxy implementation, such as Traefik, Caddy, Nginx, and Apache (ordered by initial release from newer to older).</p>\n<p>Our pick is <a href=\"https://hub.docker.com/_/nginx\">Nginx</a>. </p>\n<p>Let us now put the <i>hello-frontend</i> behind the reverse proxy.</p>\n<p>Create a file <i>nginx.dev.conf</i> in the project root and take the following template as a starting point. We will need to do minor edits to have our application running:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># events is required, but defaults are ok</span>\nevents <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># A http server, listening at port 80</span>\nhttp <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\"># Requests starting with root (/) are handled</span>\n    location / <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\"># The following 3 lines are required for the hot loading to work (websocket).</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n      <span class=\"token comment\"># Requests are directed to http://localhost:5173</span>\n      proxy_pass http://localhost:5173<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Note</strong> we are using the familiar naming convention also for Nginx, <i>nginx.dev.conf</i> for development configurations, and the default name <i>nginx.conf</i> otherwise.</p>\n<p>Next, create an Nginx service in the <i>docker-compose.dev.yml</i> file. Add a volume as instructed in the Docker Hub page where the right side is <em>:/etc/nginx/nginx.conf:ro</em>, the final ro declares that the volume will be <i>read-only</i>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># ...</span>\n  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.dev.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app <span class=\"token comment\"># wait for the frontend container to be started</span></code></pre></div>\n<p>with that added, we can run <em>docker compose -f docker-compose.dev.yml up</em> and see what happens.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE            COMMAND  PORTS                   NAMES\na02ae58f3e8d   nginx:1.20.1     <span class=\"token punctuation\">..</span>.      <span class=\"token number\">0.0</span>.0.0:8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp    reverse-proxy\n5ee0284566b4   hello-front-dev  <span class=\"token punctuation\">..</span>.      <span class=\"token number\">0.0</span>.0.0:5173-<span class=\"token operator\">></span><span class=\"token number\">5173</span>/tcp  hello-front-dev</code></pre></div>\n<p>Connecting to <a href=\"http://localhost:8080\">http://localhost:8080</a> will lead to a familiar-looking page with 502 status. </p>\n<p>This is because directing requests to <a href=\"http://localhost:5173\">http://localhost:5173</a> leads to nowhere as the Nginx container does not have an application running in port 5173. By definition, localhost refers to the current computer used to access it. Since the localhost is unique for each container, it always points to the container itself.</p>\n<p>Let's test this by going inside the Nginx container and using curl to send a request to the application itself. In our usage curl is similar to wget, but won't need any flags.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> reverse-proxy <span class=\"token function\">bash</span>  \n\nroot@374f9e62bfa8:<span class=\"token punctuation\">\\</span># <span class=\"token function\">curl</span> http://localhost:80\n  <span class=\"token operator\">&lt;</span>html<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>title<span class=\"token operator\">></span><span class=\"token number\">502</span> Bad Gateway<span class=\"token operator\">&lt;</span>/title<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>/head<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>To help us, Docker Compose has set up a network when we ran <em>docker compose up</em>. It has also added all of the containers mentioned in the <i>docker-compose.dev.yml</i> to the network. A DNS makes sure we can find the other containers in the network. The containers are each given two names: the service name and the container name and both can be used to communicate with a container.</p>\n<p>Since we are inside the container, we can also test the DNS! Let's curl the service name (app) in port 5173</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">root@374f9e62bfa8:\\# curl http://app:5173\n<span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">doctype</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/@vite/client<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>icon<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/svg+xml<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/vite.svg<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>width=device-width, initial-scale=1.0<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Vite + React<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>root<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/src/main.jsx<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>That is it! Let's replace the proxy_pass address in nginx.dev.conf with that one.</p>\n<p>One more thing: we added an option <a href=\"https://docs.docker.com/compose/compose-file/05-services/#depends_on\">depends_on</a> to the configuration that ensures that the <em>nginx</em> container is not started before the frontend container <em>app</em> is started:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">services:\n  app:\n    <span class=\"token comment\"># ...</span>\n  nginx:\n    image: nginx:1.20.1\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    ports:\n      - <span class=\"token number\">8080</span>:80\n    container_name: reverse-proxy\n<span class=\"gatsby-highlight-code-line\">    depends_on:</span><span class=\"gatsby-highlight-code-line\">      - app</span></code></pre></div>\n<p>If we do not enforce the starting order with <i>depends_on</i> there a risk that Nginx fails on startup since it tries to resolve all DNS names that are referred in the config file:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">http <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    location / <span class=\"token punctuation\">{</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n<span class=\"gatsby-highlight-code-line\">      proxy_pass http://app:5173<span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p> Note that <i>depends_on</i> does not guarantee that the service in the depended container is ready for action, it just ensures that the container has been started (and the corresponding entry is added to DNS). If a service needs to wait another service to become ready before the startup, <a href=\"https://docs.docker.com/compose/startup-order/\">other solutions</a> should be used.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.17. - 12.19.</h3>\n<h4>Exercise 12.17: Set up an Nginx reverse proxy server in front of todo-frontend</h4>\n<p>We are going to put the Nginx server in front of both todo-frontend and todo-backend. Let's start by creating a new docker-compose file <i>todo-app/docker-compose.dev.yml</i> and <i>todo-app/nginx.dev.conf</i>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n<span class=\"gatsby-highlight-code-line\">├── nginx.dev.conf</span><span class=\"gatsby-highlight-code-line\">└── docker-compose.dev.yml</span></code></pre></div>\n<p>Add the services Nginx and the todo-frontend built with <i>todo-app/todo-frontend/dev.Dockerfile</i> into the <i>todo-app/docker-compose.dev.yml</i>.</p>\n<picture><img src=\"/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png\" alt=\"connection diagram between browser, nginx, express and frontend\" srcset=\"/static/a5c3b8d70abca3569ed532e053af7bc7/772e8/ex_12_16_nginx_front.png 200w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/e17e5/ex_12_16_nginx_front.png 400w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<p>In this and the following exercises you <strong>do not</strong> need to support the build option, that is, the command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up <span class=\"token parameter variable\">--build</span></code></pre></div>\n<p>It is enough to build the frontend and backend at their own repositories.</p>\n<h4>Exercise 12.18: Configure the Nginx server to be in front of todo-backend</h4>\n<p>Add the service todo-backend to the docker-compose file <i>todo-app/docker-compose.dev.yml</i> in development mode.</p>\n<p>Add a new location to the <i>nginx.dev.conf</i> file, so that requests to <em>/api</em> are proxied to the backend. Something like this should do the trick:</p>\n<div class=\"gatsby-highlight\" data-language=\"conf\"><pre class=\"language-conf\"><code class=\"language-conf\">  server {\n    listen 80;\n\n    # Requests starting with root (/) are handled\n    location / {\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &#39;upgrade&#39;;\n      \n      proxy_pass ...\n    }\n\n    # Requests starting with /api/ are handled\n    location /api/ {\n      proxy_pass ...\n    }\n  }</code></pre></div>\n<p>The <em>proxy_pass</em> directive has an interesting feature with a trailing slash. As we are using the path <em>/api</em> for location but the backend application only answers in paths <em>/</em> or <em>/todos</em> we will want the <em>/api</em> to be removed from the request. In other words, even though the browser will send a GET request to <em>/api/todos/1</em> we want the Nginx to proxy the request to <em>/todos/1</em>. Do this by adding a trailing slash <em>/</em> to the URL at the end of <em>proxy_pass</em>.</p>\n<p>This is a <a href=\"https://serverfault.com/questions/562756/how-to-remove-the-path-with-an-nginx-proxy-pass\">common issue</a></p>\n<picture><img src=\"/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png\" alt=\"comments about forgetting to use the trailing slash\" srcset=\"/static/356d6b54ad3287d7e031093366b578bf/772e8/nginx_trailing_slash_stackoverflow.png 200w,\n/static/356d6b54ad3287d7e031093366b578bf/e17e5/nginx_trailing_slash_stackoverflow.png 400w,\n/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png 666w\" sizes=\"(max-width: 666px) 100vw, 666px\"></picture>\n<p>This illustrates what we are looking for and may be helpful if you are having trouble:</p>\n<picture><img src=\"/static/588d3e2d00a8bd46cb059cc22b648839/15d25/nginx-back-vite.png\" alt=\"diagram of calling / and /api in action\" srcset=\"/static/588d3e2d00a8bd46cb059cc22b648839/772e8/nginx-back-vite.png 200w,\n/static/588d3e2d00a8bd46cb059cc22b648839/e17e5/nginx-back-vite.png 400w,\n/static/588d3e2d00a8bd46cb059cc22b648839/15d25/nginx-back-vite.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<h4>Exercise 12.19: Connect the services, todo-frontend with todo-backend</h4>\n<blockquote>\n<p>In this exercise, submit the entire development environment, including both Express and React applications, dev.Dockerfiles and docker-compose.dev.yml.</p>\n</blockquote>\n<p>Finally, it is time to put all the pieces together. Before starting, it is essential to understand <i>where</i> the React app is actually run. The above diagram might give the impression that React app is run in the container but it is totally wrong. </p>\n<p>It is just the <i>React app source code</i> that is in the container. When the browser hits the address <a href=\"http://localhost:8080\">http://localhost:8080</a> (assuming that you set up Nginx to be accessed in port 8080), the React source code gets downloaded from the container to the browser:</p>\n<picture><img src=\"/static/173caa8364344802dfa484a3fe62eb8f/3ebb1/nginx-setup-vite.png\" alt=\"diagram showing that the react code is sent to the browser for its execution\" srcset=\"/static/173caa8364344802dfa484a3fe62eb8f/772e8/nginx-setup-vite.png 200w,\n/static/173caa8364344802dfa484a3fe62eb8f/e17e5/nginx-setup-vite.png 400w,\n/static/173caa8364344802dfa484a3fe62eb8f/3ebb1/nginx-setup-vite.png 507w\" sizes=\"(max-width: 507px) 100vw, 507px\"></picture>\n<p>Next, the browser starts executing the React app, and all the requests it makes to the backend should be done through the Nginx reverse proxy:</p>\n<picture><img src=\"/static/5c2e45fa07a35a51f5e7ec209d497690/92e00/nginx-setup2.png\" alt=\"diagram showing requests made from the browser to /api of nginx and the proxy in action proxying the request to /todos\" srcset=\"/static/5c2e45fa07a35a51f5e7ec209d497690/772e8/nginx-setup2.png 200w,\n/static/5c2e45fa07a35a51f5e7ec209d497690/e17e5/nginx-setup2.png 400w,\n/static/5c2e45fa07a35a51f5e7ec209d497690/92e00/nginx-setup2.png 511w\" sizes=\"(max-width: 511px) 100vw, 511px\"></picture>\n<p>The frontend container is actually only accessed on the first request that gets the React app source code to the browser.</p>\n<p>Now set up your app to work as depicted in the above figure. Make sure that the todo-frontend works with todo-backend. It will require changes to the <em>VITE_BACKEND_URL</em> environmental variable in the frontend.</p>\n<p>Make sure that the development environment is now fully functional, that is:</p>\n<ul>\n<li>all features of the todo app work</li>\n<li>you can edit the source files <i>and</i> the changes take effect by reloading the app</li>\n<li>frontend should access the backend through Nginx, so the requests should be done to <a href=\"http://localhost:8080/api/todos\">http://localhost:8080/api/todos</a>:</li>\n</ul>\n<picture><img src=\"/static/dba7f9421034549551a10a7c0063fc84/5a190/todos-dev-right-2.png\" alt=\"network tab of the browser developer tools showing that the url request includes 8080/api/todos\" srcset=\"/static/dba7f9421034549551a10a7c0063fc84/772e8/todos-dev-right-2.png 200w,\n/static/dba7f9421034549551a10a7c0063fc84/e17e5/todos-dev-right-2.png 400w,\n/static/dba7f9421034549551a10a7c0063fc84/5a190/todos-dev-right-2.png 800w,\n/static/dba7f9421034549551a10a7c0063fc84/c1b63/todos-dev-right-2.png 1200w,\n/static/dba7f9421034549551a10a7c0063fc84/29007/todos-dev-right-2.png 1600w,\n/static/dba7f9421034549551a10a7c0063fc84/010dc/todos-dev-right-2.png 1714w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Note that your app should work even if no <a href=\"https://docs.docker.com/network/#published-ports\">exposed port</a> are defined for the backend and frontend in the docker compose file:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> todo<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./todo<span class=\"token punctuation\">-</span>frontend/<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token comment\"># no ports here!</span>\n\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> todo<span class=\"token punctuation\">-</span>back<span class=\"token punctuation\">-</span>dev\n      <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> ./todo<span class=\"token punctuation\">-</span>backend/<span class=\"token punctuation\">:</span>/usr/src/app\n      <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n        <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n      <span class=\"token comment\"># no ports here!</span>\n\n  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span> <span class=\"token comment\"># this is needed</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app</code></pre></div>\n<p>We just need to expose the Nginx port to the host machine since the access to the backend and frontend is proxied to the right container port by Nginx. Because Nginx, frontend and backend are defined in the same Docker compose configuration, Docker puts those to the same <a href=\"https://docs.docker.com/network/\">Docker network</a> and thanks to that, Nginx has direct access to frontend and backend containers ports.</p>\n</div>\n<div class=\"content\">\n<h3>Tools for Production</h3>\n<p>Containers are fun tools to use in development, but the best use case for them is in the production environment. There are many more powerful tools than Docker Compose to run containers in production.</p>\n<p>Heavyweight container orchestration tools like <a href=\"https://kubernetes.io/\">Kubernetes</a> allow us to manage containers on a completely new level. These tools hide away the physical machines and allow us, the developers, to worry less about the infrastructure.</p>\n<p>If you are interested in learning more in-depth about containers come to the <a href=\"https://devopswithdocker.com\">DevOps with Docker</a> course and you can find more about Kubernetes in the advanced 5 credit <a href=\"https://devopswithkubernetes.com\">DevOps with Kubernetes</a> course. You should now have the skills to complete both of them!</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.20.-12.22.</h3>\n<h4>Exercise 12.20:</h4>\n<p>Create a production <i>todo-app/docker-compose.yml</i> file with all of the services, Nginx, todo-backend, todo-frontend, MongoDB and Redis. Use Dockerfiles instead of <i>dev.Dockerfiles</i> and make sure to start the applications in production mode.</p>\n<p>Please use the following structure for this exercise:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n├── nginx.dev.conf\n├── docker-compose.dev.yml\n<span class=\"gatsby-highlight-code-line\">├── nginx.conf</span><span class=\"gatsby-highlight-code-line\">└── docker-compose.yml</span></code></pre></div>\n<h4>Exercise 12.21:</h4>\n<p>Create a similar containerized development environment of one of <i>your own</i> full stack apps that you have created during the course or in your free time. You should structure the app in your submission repository as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    ├── nginx.dev.conf\n    └── docker-compose.dev.yml</code></pre></div>\n<h4>Exercise 12.22:</h4>\n<p>Finish this part by creating a containerized <i>production setup</i> of your own full stack app.\nStructure the app in your submission repository as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    ├── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── nginx.dev.conf\n    ├── nginx.conf\n    ├── docker-compose.dev.yml\n    └── docker-compose.yml</code></pre></div>\n<h3>Submitting exercises and getting the credits</h3>\n<p>This was the last exercise in this section. It's time to push your code to GitHub and mark all of your finished exercises to the <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">exercise submission system</a>.</p>\n<p>Exercises of this part are submitted just like in the previous parts, but unlike parts 0 to 7, the submission goes to an own <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">course instance</a>. Remember that you have to finish <i>all the exercises</i> to pass this part!</p>\n<p>Once you have completed the exercises and want to get the credits, let us know through the exercise submission system that you have completed the course:</p>\n<picture><img src=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png\" alt=\"Submissions\" srcset=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/772e8/21.png 200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/e17e5/21.png 400w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png 800w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/c1b63/21.png 1200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/29007/21.png 1600w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/74e37/21.png 1732w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><strong>Note</strong> that you need a registration to the corresponding course part for getting the credits registered, see <a href=\"/en/part0/general_info#parts-and-completion\">here</a> for more information.</p>\n<p>You can download the certificate for completing this part by clicking one of the flag icons. The flag icon corresponds to the certificate's language. </p>\n</div>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"c","lang":"en"}}},"pageContext":{"part":12,"letter":"c","lang":"en"}},"staticQueryHashes":["3128451518"]}