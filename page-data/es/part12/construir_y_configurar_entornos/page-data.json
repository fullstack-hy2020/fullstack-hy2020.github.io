{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/construir_y_configurar_entornos","result":{"data":{"markdownRemark":{"html":"<div class=\"tasks\">\n<p>Esta parte fue actualizada el 21 de Marzo de 2024: Create react app reemplazado con Vite en el frontend de todo.</p>\n<p>Si comenzaste esta parte antes de la actualización, puedes ver el viejo material <a href=\"https://github.com/fullstack-hy2020/fullstack-hy2020.github.io/tree/4015af9dddb61cb01f013456d8728e8f553be347/src/content/12\">aquí</a>. Hay algunos cambios en las configuraciones del frontend.</p>\n</div>\n<div class=\"content\">\n<p>En la sección anterior, usamos dos imágenes base diferentes: ubuntu y node, e hicimos un trabajo manual para ejecutar un simple \"¡Hola, mundo!\". Las herramientas y los comandos que aprendimos durante ese proceso nos serán útiles más adelante. En esta sección, aprenderemos a crear imágenes y configurar entornos para nuestras aplicaciones. Comenzaremos con un backend regular de Express/Node.js y lo desarrollaremos con otros servicios, incluida una base de datos MongoDB.</p>\n<h3>Dockerfile</h3>\n<p>En lugar de modificar un contenedor copiando archivos dentro, podemos crear una nueva imagen que contenga la aplicación \"¡Hola, mundo!\". La herramienta para esto es el Dockerfile. Dockerfile es un archivo de texto simple que contiene todas las instrucciones para crear una imagen. Vamos a crear un Dockerfile de ejemplo a partir de la aplicación \"Hello, World!\".</p>\n<p>Si aún no lo hiciste, crea un directorio en tu máquina y crea un archivo llamado <i>Dockerfile</i> dentro de ese directorio. También coloquemos un <i>index.js</i> que contenga <em>console.log('Hello, World!')</em> al lado del Dockerfile. La estructura de su directorio debería verse así:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── index.js\n└── Dockerfile</code></pre></div>\n<p>Dentro de ese Dockerfile le diremos a la imagen tres cosas:</p>\n<ul>\n<li>Usa <a href=\"https://hub.docker.com/_/node\">node:20</a> como base para nuestra imagen.</li>\n<li>Incluye al archivo index.js dentro de la imagen, así no necesitaremos copiarlo manualmente en el contenedor</li>\n<li>Cuando ejecutemos el contenedor desde la imagen, usa node para ejecutar el archivo index.js.</li>\n</ul>\n<p>Las instrucciones anteriores se traducirán en un Dockerfile básico. La mejor ubicación para colocar este archivo suele ser la raíz del proyecto.</p>\n<p>El archivo <i>Dockerfile</i> resultante se ve así:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./index.js ./index.js</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> node index.js</span></code></pre></div>\n<p>La instrucción FROM le dirá a Docker que la base de la imagen debe ser node:20. La instrucción COPY copiará el archivo <i>index.js</i> de la máquina host al archivo con el mismo nombre en la imagen. La instrucción CMD dice lo que sucede cuando se usa <em>docker run</em>. CMD es el comando predeterminado que luego se puede sobrescribir con el argumento dado después del nombre de la imagen. Consulta <em>docker run --help</em> si lo has olvidado.</p>\n<p>La instrucción WORKDIR se introdujo para garantizar que no interfiramos con el contenido de la imagen. Garantizará que todos los siguientes comandos tendrán <i>/usr/src/app</i> configurado como el directorio de trabajo. Si el directorio no existe en la imagen base, se creará automáticamente.</p>\n<p>Si no especificamos un WORKDIR, corremos el riesgo de sobrescribir archivos importantes por accidente. Si verificas la raíz (<em>/</em>) de la imagen node:20 con <em>docker run node:20 ls</em>, puedes notar todos los directorios y archivos que ya están incluidos en la imagen.</p>\n<p>Ahora podemos usar el comando <em>docker build</em> para construir una imagen basada en el Dockerfile. Vamos a modificar el comando con una bandera adicional: <em>-t</em>, esto nos ayudará a nombrar la imagen:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> fs-hello-world <span class=\"token builtin class-name\">.</span> \n<span class=\"token punctuation\">[</span>+<span class=\"token punctuation\">]</span> Building <span class=\"token number\">3</span>.9s <span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/8<span class=\"token punctuation\">)</span> FINISHED\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Entonces, el resultado es \"Docker, por favor construye con la etiqueta (puedes pensar que la etiqueta es el nombre de la imagen resultante.) <i>fs-hello-world</i> el Dockerfile en este directorio\". Puedes apuntar a cualquier Dockerfile, pero en nuestro caso, un simple punto significará el Dockerfile en <i>este</i> directorio. Es por eso que el comando termina con un punto. Una vez finalizado el build, puedes ejecutarlo con <em>docker run fs-hello-world</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run fs-hello-world\nHello, World</code></pre></div>\n<p>Como las imágenes son solo archivos, se pueden mover, descargar y eliminar. Puedes enumerar las imágenes que tienes localmente con <em>docker image ls</em>, eliminarlas con <em>docker image rm</em>. Ve qué otro comando tienes disponible con <em>docker image --help</em>.</p>\n<p>Una cosa más: antes se mencionó que el comando predeterminado, definido por CMD en el Dockerfile, puede ser sobre-escrito si fuera necesario. Podríamos, por ejemplo, abrir una sesión de bash en el contenedor y observar su contenido:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> fs-hello-world <span class=\"token function\">bash</span>\nroot@2932e32dbc09:/usr/src/app<span class=\"token comment\"># ls</span>\nindex.js\nroot@2932e32dbc09:/usr/src/app<span class=\"token comment\">#</span></code></pre></div>\n<h3>Imagen más significativa</h3>\n<p>Mover un servidor Express a un contenedor debería ser tan simple como mover la aplicación \"¡Hola, mundo!\" dentro de un contenedor. La única diferencia es que hay más archivos. Afortunadamente, la instrucción <em>COPY</em> puede manejar todo eso. Eliminemos index.js y creemos un nuevo servidor Express. Usemos <a href=\"https://expressjs.com/en/starter/generator.html\">express-generator</a> para crear el esqueleto básico de una aplicación Express.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ npx express-generator\n  <span class=\"token punctuation\">..</span>.\n  \n  <span class=\"token function\">install</span> dependencies:\n    $ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>\n\n  run the app:\n    $ <span class=\"token assign-left variable\">DEBUG</span><span class=\"token operator\">=</span>playground:* <span class=\"token function\">npm</span> start</code></pre></div>\n<p>Primero, ejecutemos la aplicación para tener una idea de lo que acabamos de crear. Ten en cuenta que el comando para ejecutar la aplicación puede ser diferente al tuyo, mi directorio se llama playground.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>\n$ <span class=\"token assign-left variable\">DEBUG</span><span class=\"token operator\">=</span>playground:* <span class=\"token function\">npm</span> start\n  playground:server Listening on port <span class=\"token number\">3000</span> +0ms</code></pre></div>\n<p>Genial, ahora podemos navegar a <a href=\"http://localhost:3000\">http://localhost:3000</a> y la aplicación se está ejecutando allí.</p>\n<p>Poner la aplicación en un contenedor debería ser relativamente fácil según el ejemplo anterior.</p>\n<ul>\n<li>Usar node como base</li>\n<li>Establecer el directorio de trabajo para que no interfiramos con el contenido de la imagen base</li>\n<li>Copia TODOS los archivos en este directorio a la imagen</li>\n<li>Ejecútala con DEBUG=playground:* npm start</li>\n</ul>\n<p>Coloquemos el siguiente Dockerfile en la raíz del proyecto:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>Construiremos la imagen desde Dockerfile y luego la ejecutaremos: </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> express-server <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">3123</span>:3000 express-server </code></pre></div>\n<p>La bandera <em>-p</em> informará a Docker de que se debe abrir un puerto de la máquina host y dirigirlo a un puerto en el contenedor. El formato es <em>-p host-port:application-port</em>.</p>\n<p>¡La aplicación ya se está ejecutando! Probémoslo enviando una solicitud GET a <a href=\"http://localhost:3123/\">http://localhost:3123/</a>.</p>\n<blockquote>\n<p>Si el tuyo no funciona, pasa a la siguiente sección. Hay una explicación de por qué puede que no funcione incluso si has seguido los pasos correctamente.</p>\n</blockquote>\n<p>Cerrarlo es un dolor de cabeza en este momento. Usa otro terminal y el comando <em>docker kill</em> para cerrar la aplicación. El <em>docker kill</em> enviará una señal de eliminación (SIGKILL) a la aplicación para obligarla a cerrarse. Necesitas el nombre o id del contenedor como argumento.</p>\n<p>Por cierto, cuando se usa id como argumento, el comienzo de la ID es suficiente para que Docker sepa a qué contenedor nos referimos.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\n  CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                                       NAMES\n  48096ca3ffec   express-server   <span class=\"token string\">\"docker-entrypoint.s…\"</span>   <span class=\"token number\">9</span> seconds ago   Up <span class=\"token number\">6</span> seconds   <span class=\"token number\">0.0</span>.0.0:3123-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp, :::3123-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp   infallible_booth\n\n$ <span class=\"token function\">docker</span> <span class=\"token function\">kill</span> <span class=\"token number\">48</span>\n  <span class=\"token number\">48</span></code></pre></div>\n<p>En el futuro, usemos el mismo puerto en ambos lados de <em>-p</em>. Solo para que no tengamos que recordar cuál elegimos.</p>\n<h4>Solucionar problemas potenciales que creamos al copiar y pegar</h4>\n<p>Hay algunos cambios que debemos realizar para crear un Dockerfile más completo. Incluso puede ser que el ejemplo anterior no funcione en todos los casos porque nos saltamos un paso importante.</p>\n<p>Cuando ejecutamos npm install en nuestra máquina, en algunos casos el <strong>administrador de paquetes de node (npm)</strong> puede instalar dependencias específicas del sistema operativo durante el paso de instalación. Es posible que accidentalmente movamos partes no funcionales a la imagen con la instrucción COPY. Esto puede suceder fácilmente si copiamos el directorio <i>node_modules</i> en la imagen.</p>\n<p>Esto es algo crítico a tener en cuenta cuando construimos nuestras imágenes. Es mejor hacer la mayoría de las cosas, como ejecutar <em>npm install</em> durante el proceso de compilación <i>dentro del contenedor</i> en lugar de hacerlo antes de compilar. La regla general es copiar solo los archivos que enviarías a GitHub. Los artefactos o las dependencias de compilación no se deben copiar, ya que se pueden instalar durante el proceso de compilación.</p>\n<p>Podemos usar <i>.dockerignore</i> para resolver el problema. El archivo .dockerignore es muy similar a .gitignore, puedes usarlo para evitar que se copien archivos no deseados en tu imagen. El archivo debe colocarse junto al Dockerfile. Aquí hay un posible contenido de un <i>.dockerignore</i></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.dockerignore\n.gitignore\nnode_modules\nDockerfile</code></pre></div>\n<p>Sin embargo, en nuestro caso, .dockerignore no es lo único que se requiere. Tendremos que instalar las dependencias durante el paso de compilación. El <em>Dockerfile</em> cambia a:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>La instalación de npm puede ser riesgosa. En lugar de usar npm install, npm ofrece una herramienta mucho mejor para instalar dependencias, el comando <em>ci</em>.</p>\n<p>Diferencias entre ci e install:</p>\n<ul>\n<li>install puede actualizar el package-lock.json</li>\n<li>install puede instalar una versión diferente de una dependencia si tiene ^ o ~ en la versión de la dependencia.</li>\n<li>ci eliminará la carpeta node_modules antes de instalar cualquier cosa</li>\n<li>ci seguirá el package-lock.json y no alterará ningún archivo</li>\n</ul>\n<p>En resumen: <em>ci</em> crea compilaciones confiables, mientras que <em>install</em> es el que se usa cuando deseas instalar nuevas dependencias.</p>\n<p>Como no estamos instalando nada nuevo durante el paso de compilación y no queremos que las versiones cambien repentinamente, usaremos <em>ci</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>Aún mejor, podemos usar <em>npm ci --omit=dev</em> para no perder tiempo instalando dependencias de desarrollo.</p>\n<blockquote>\n<p>Como habrás notado en la lista de comparación; npm ci eliminará la carpeta node_modules, por lo que no importó crear el .dockerignore. Sin embargo, .dockerignore es una herramienta increíble cuando deseas optimizar tu proceso de compilación. Hablaremos brevemente sobre estas optimizaciones más adelante.</p>\n</blockquote>\n<p>Ahora el Dockerfile debería funcionar de nuevo, pruébalo con <em>docker build -t express-server . &#x26;&#x26; docker run -p 3123:3000 express-server</em></p>\n<blockquote>\n<p>Ten en cuenta que estamos aquí encadenando dos comandos bash con &#x26;&#x26;. Podríamos obtener (casi) el mismo efecto ejecutando ambos comandos por separado. Al encadenar comandos con &#x26;&#x26;, si un comando falla, los siguientes de la cadena no se ejecutarán.</p>\n</blockquote>\n<p>Configuramos una variable de entorno <em>DEBUG=playground:*</em> durante CMD para el inicio de npm. Sin embargo, con Dockerfiles también podríamos usar la instrucción ENV para establecer variables de entorno. Vamos a hacer eso:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci </span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBUG=playground:*</span></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> npm start</span></span></code></pre></div>\n<blockquote>\n<p><i>Si te preguntas qué hace la variable de entorno DEBUG, lee <a href=\"https://expressjs.com/en/guide/debugging.html\">Debugging Express</a>.</i></p>\n</blockquote>\n<h4>Mejores prácticas de Dockerfile</h4>\n<p>Hay 2 reglas generales que debes seguir al crear imágenes:</p>\n<ul>\n<li>Intenta crear una imagen lo más <strong>segura</strong> posible</li>\n<li>Intenta crear una imagen lo más <strong>pequeña</strong> posible</li>\n</ul>\n<p>Las imágenes más pequeñas son más seguras al tener menos área de superficie de ataque, y también se mueven más rápido en las pipelines de despliegue.</p>\n<p>Snyk tiene una excelente lista de las <a href=\"https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/\">10 mejores prácticas para la creación de contenedores de node/express</a>.</p>\n<p>Un gran descuido que debemos resolver es ejecutar la aplicación como root en lugar de usar un usuario con menos privilegios. Hagamos un ultimo arreglo al Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:20</span>\n  \n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--chown</span><span class=\"token punctuation\">=</span><span class=\"token string\">node:node</span></span> . .</span></span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci </span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBUG=playground:*</span>\n  \n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">USER</span> node</span></span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> npm start</span></code></pre></div>\n</div>\n  \n<div class=\"tasks\">\n<h3>Ejercicio 12.5.</h3>\n<h4>Ejercicio 12.5: Contenedorización de una aplicación de Node.js</h4>\n<p>El repositorio que clonaste o copiaste en el <a href=\"/es/part12/introduccion_a_los_contenedores#ejercicio-12-1\">primer ejercicio</a> contiene una aplicación de tareas (todo-app). Échale un vistazo a todo-app/todo-backend y lee el README. Todavía no tocaremos todo-frontend.</p>\n<ul>\n<li>Paso 1. Pon a todo-backend en un contenedor creando un <i>todo-app/todo-backend/Dockerfile</i> y construyendo una imagen.</li>\n<li>Paso 2. Ejecuta la imagen de todo-backend con los puertos correctos abiertos. Asegúrate de que el contador de visitas aumente cuando se usa a través de un navegador en <a href=\"http://localhost:3000/\">http://localhost:3000/</a> (o algún otro puerto si lo configuras)</li>\n</ul>\n<p>Sugerencia: Ejecuta la aplicación fuera de un contenedor para examinarla antes de comenzar.</p>\n</div>\n  \n<div class=\"content\">\n<h3>Utilizando docker-compose</h3>\n<p>En la sección anterior, creamos un servidor Express, sabiendo que se ejecutaría en el puerto 3123, y utilizamos los comandos <em>docker build -t express-server . &#x26;&#x26; docker run -p 3123:3000 express-server</em> para ejecutarlo. Esto ya parece algo que necesitarías poner en un script para recordarlo. Afortunadamente, Docker nos ofrece una mejor solución.</p>\n<p><a href=\"https://docs.docker.com/compose/\">Docker-compose</a> es otra herramienta fantástica que puede ayudarnos a administrar contenedores. Comencemos a usar docker-compose a medida que aprendamos más sobre los contenedores, ya que nos ayudará a ahorrar algo de tiempo con la configuración.</p>\n<p>Y ahora podemos convertir el hechizo anterior en un archivo yaml. ¡La mejor parte de los archivos yaml es que puedes guardarlos en un repositorio de Git!</p>\n<p>Crea el archivo <strong>docker-compose.yml</strong> y colócalo en la raíz del proyecto, junto al Dockerfile. Esta vez utilizaremos el mismo puerto para host y contenedor. El contenido del archivo es:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>                    <span class=\"token comment\"># The name of the service, can be anything</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> express<span class=\"token punctuation\">-</span>server <span class=\"token comment\"># Declares which image to use</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .              <span class=\"token comment\"># Declares where to build if image is not found</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>                <span class=\"token comment\"># Declares the ports to publish</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span></code></pre></div>\n<p>El significado de cada línea se explica como un comentario. Si deseas ver la especificación completa, consulta la <a href=\"https://docs.docker.com/compose/compose-file/\">documentación</a>.</p>\n<p>Ahora podemos usar <em>docker compose up</em> para compilar y ejecutar la aplicación. Si queremos reconstruir las imágenes podemos usar <em>docker compose up --build</em>.</p>\n<p>También puedes ejecutar la aplicación en segundo plano con <em>docker compose up -d</em> (<em>-d</em> para separado) y cerrarla con <em>docker compose down</em>.</p>\n<blockquote>\n<p><i>Ten en cuenta que algunas versiones antiguas de Docker (especialmente en Windows) no soportan el comando <em>docker compose</em>. Una forma de evitar este problema es <a href=\"https://docs.docker.com/compose/install/\">instalando</a> el comando <em>docker-compose</em> que funciona casi siempre igual que <em>docker compose</em>. Sin embargo, la solución preferible es actualizar Docker a su versión más reciente.</i></p>\n</blockquote>\n<p>Crear archivos como <em>docker-compose.yml</em> que <i>declaran</i> lo que deseas en lugar de archivos de script que necesitas ejecutar en un orden específico / un número específico de veces es a menudo una buena práctica.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.6.</h3>\n<h4>Ejercicio 12.6: Docker compose</h4>\n<p>Crea un archivo <i>todo-app/todo-backend/docker-compose.yml</i> que funcione con la aplicación de node del ejercicio anterior.</p>\n<p>El contador de visitas es la única funcionalidad que se requiere que funcione.</p>\n</div>\n<div class=\"content\">\n<h3>Uso de contenedores en desarrollo</h3>\n<p>Cuando estás desarrollando software, la contenedorización se puede utilizar de varias maneras para mejorar tu calidad de vida. Uno de los casos más útiles es evitar la necesidad de instalar y configurar las herramientas dos veces.</p>\n<p>Puede que no sea la mejor opción mover todo tu entorno de desarrollo a un contenedor, pero si eso es lo que deseas, es posible. Retomaremos esta idea al final de esta parte. Pero hasta entonces, <i>ejecuta la propia aplicación de Node fuera de los contenedores</i>.</p>\n<p>La aplicación que conocimos en los ejercicios anteriores utiliza MongoDB. Exploremos <a href=\"https://hub.docker.com/\">Docker Hub</a> para encontrar una imagen de MongoDB. Docker Hub es el lugar predeterminado desde donde Docker extrae las imágenes, también puedes usar otros registros, pero dado que ya estamos metidos hasta las rodillas en Docker, es una buena opción. Con una búsqueda rápida, podemos encontrar <a href=\"https://hub.docker.com/_/mongo\">https://hub.docker.com/_/mongo</a></p>\n<p>Crea un nuevo yaml llamado <i>todo-app/todo-backend/docker-compose.dev.yml</i> que se parece a lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database</code></pre></div>\n<p>El significado de las dos primeras variables de entorno definidas anteriormente se explica en la página de Docker Hub:</p>\n<blockquote>\n<p><i>Estas variables, usadas en conjunto, crean un nuevo usuario y establecen la contraseña de ese usuario. Este usuario se crea en la base de datos de autenticación del administrador y se le otorga el rol de root (\"superusuario\").</i></p>\n</blockquote>\n<p>La última variable de entorno <em>MONGO_INITDB_DATABASE</em> le indicará a MongoDB que cree una base de datos con ese nombre.</p>\n<p>Puedes usar la bandera <em>-f</em> para especificar un <i>archivo</i> que se ejecute con el comando Docker Compose, por ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up</code></pre></div>\n<p>Ahora que podríamos tener multiples archivos de compose, es útil.</p>\n<p>A continuación, inicia MongoDB con <em>docker compose -f docker-compose.dev.yml up -d</em>. Con <em>-d</em> se ejecutará en segundo plano. Puedes ver los registros del output con <em>docker compose -f docker-compose.dev.yml logs -f</em>. Allí, <em>-f</em> se asegurará de que <i>seguimos</i> los registros.</p>\n<p>Como se dijo anteriormente, actualmente <strong>no</strong> queremos ejecutar la aplicación Node dentro de un contenedor. Desarrollar mientras la aplicación está dentro de un contenedor es un desafío. Exploraremos esa opción más adelante en esta parte.</p>\n<p>Ejecuta el buen y viejo <em>npm install</em> primero en tu máquina para configurar la aplicación Node. Luego inicia la aplicación con la variable de entorno relevante. Puedes modificar el código para configurarlas como predeterminadas o usar el archivo .env. No pasa nada por poner estas claves en GitHub, ya que solo se usan en tu entorno de desarrollo local. Las agregaré con <em>npm run dev</em> para ayudarte a copiar y pegar.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Esto no será suficiente; necesitamos crear un usuario para ser autorizado dentro del contenedor. La url <a href=\"http://localhost:3000/todos\">http://localhost:3000/todos</a> genera un error de autenticación:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> <span class=\"token number\">2.0</span>.12\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> to restart at any time, enter <span class=\"token variable\"><span class=\"token variable\">`</span>rs<span class=\"token variable\">`</span></span>\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> watching path<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>: *.*\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> watching extensions: js,mjs,json\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> starting <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">node</span> ./bin/www<span class=\"token variable\">`</span></span>\n/Users/mluukkai/dev/fs-ci-lokakuu/repo/todo-app/todo-backend/node_modules/mongodb/lib/cmap/connection.js:272\n          callback<span class=\"token punctuation\">(</span>new MongoError<span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n                   ^\nMongoError: <span class=\"token builtin class-name\">command</span> <span class=\"token function\">find</span> requires authentication\n    at MessageStream.messageHandler <span class=\"token punctuation\">(</span>/Users/mluukkai/dev/fs-ci-lokakuu/repo/todo-app/todo-backend/node_modules/mongodb/lib/cmap/connection.js:272:20<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Vincular e inicializar la base de datos</h3>\n<p>En la página <a href=\"https://hub.docker.com/_/mongo\">MongoDB Docker Hub</a> en la sección \"Inicializar una nueva instancia\" se encuentra la información sobre cómo ejecutar JavaScript para inicializar la base de datos y un usuario para ella.</p>\n<p>El proyecto de ejercicio tiene un archivo <i>todo-app/todo-backend/mongo/mongo-init.js</i> con el contenido:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">db<span class=\"token punctuation\">.</span><span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">user</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_username'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">pwd</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_password'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">roles</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">role</span><span class=\"token operator\">:</span> <span class=\"token string\">'dbOwner'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">db</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_database'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span><span class=\"token function\">createCollection</span><span class=\"token punctuation\">(</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">text</span><span class=\"token operator\">:</span> <span class=\"token string\">'Write code'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">done</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">text</span><span class=\"token operator\">:</span> <span class=\"token string\">'Learn about containers'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">done</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Este archivo inicializará la base de datos con un usuario y algunas tareas. A continuación, debemos colocarlo dentro del contenedor al inicio.</p>\n<p>Podríamos crear una nueva imagen DESDE mongo y COPIAR el archivo, o podemos usar un <i>bind mount</i> para montar el archivo <i>mongo-init.js</i> en el contenedor. Hagamos esto último.</p>\n<p>Bind mount es el acto de vincular un archivo (o directorio) en la máquina host a un archivo (o directorio) en el contenedor. Podríamos agregar una bandera <em>-v</em> con <em>container run</em>. La sintaxis es <em>-v ARCHIVO-EN-HOST:ARCHIVO-EN-CONTENEDOR</em>. Como ya aprendimos sobre Docker Compose, omitámoslo. El bind mount se declara bajo la clave <i>volumes</i> en <em>docker-compose.dev.yml</em>. De lo contrario, el formato es el mismo, primero host y luego contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> </span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js</span></code></pre></div>\n<p>El resultado del vínculo es que el archivo <i>mongo-init.js</i> en la carpeta mongo de la máquina host es el mismo que el archivo <i>mongo-init.js</i> en el directorio /docker-entrypoint-initdb.d del contenedor. Los cambios en cualquiera de los archivos estarán disponibles en el otro. No necesitamos hacer ningún cambio durante el tiempo de ejecución. Pero esta será la clave para el desarrollo de software en contenedores.</p>\n<p>Ejecuta <em>docker compose -f docker-compose.dev.yml down --volumes</em> para asegurarte de que no quede nada y comienza desde cero con <em>docker compose -f docker-compose.dev.yml up</em> para inicializar la base de datos.</p>\n<p>Si ves un error como este:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">mongo_database <span class=\"token operator\">|</span> failed to load: /docker-entrypoint-initdb.d/mongo-init.js\nmongo_database <span class=\"token operator\">|</span> exiting with code <span class=\"token parameter variable\">-3</span></code></pre></div>\n<p>es posible que tengas un problema de permiso de lectura. No son raros cuando se trata de volúmenes. En el caso anterior, puedes usar <em>chmod a+r mongo-init.js</em>, que les dará a todos acceso de lectura a ese archivo. Ten cuidado al usar <em>chmod</em> ya que otorgar más privilegios puede ser un problema de seguridad. Usa <em>chmod</em> solo en mongo-init.js en tu computadora.</p>\n<p>Ahora, iniciar la aplicación Express con la variable de entorno correcta debería funcionar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://the_username:the_password@localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Verifiquemos que <a href=\"http://localhost:3000/todos\">http://localhost:3000/todos</a> devuelve las tareas. Debería devolver las dos tareas que inicializamos. Podemos y <i>debemos</i> usar Postman para probar la funcionalidad básica de la aplicación, como agregar o eliminar una tarea.</p>\n<h3>¿Aún con problemas?</h3>\n<p>Por algún motivo, para muchos, la inicialización de Mongo ha causado problemas.</p>\n<p>Si la aplicación no funciona y aún tienes el siguiente error:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/Users/mluukkai/dev/fs-ci-lokakuu/repo/todo-app/todo-backend/node_modules/mongodb/lib/cmap/connection.js:272\n          callback<span class=\"token punctuation\">(</span>new MongoError<span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n                   ^\nMongoError: <span class=\"token builtin class-name\">command</span> <span class=\"token function\">find</span> requires authentication\n    at MessageStream.messageHandler <span class=\"token punctuation\">(</span>/Users/mluukkai/dev/fs-ci-lokakuu/repo/todo-app/todo-backend/node_modules/mongodb/lib/cmap/connection.js:272:20<span class=\"token punctuation\">)</span></code></pre></div>\n<p>ejecuta estos comandos:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml down <span class=\"token parameter variable\">--volumes</span>\n<span class=\"token function\">docker</span> image <span class=\"token function\">rm</span> mongo</code></pre></div>\n<p>Luego, intenta iniciar Mongo otra vez.</p>\n<p>Si el problema persiste, dejemos de lado la idea de usar un volumen y copiemos el script de inicialización a una imagen personalizada. Crea el siguiente <i>Dockerfile</i> al directorio <i>todo-app/todo-backend/mongo</i></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mongo</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./mongo-init.js /docker-entrypoint-initdb.d/</span></code></pre></div>\n<p>Agrégalo a una imagen con el comando:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> initialized-mongo <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>Ahora cambia al archivo <i>docker-compose.dev.yml</i> para que utilize la nueva imagen:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> initialized<span class=\"token punctuation\">-</span>mongo</span>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database</code></pre></div>\n<p>Ahora la aplicación debería funcionar.</p>\n<h3>Persistiendo datos con volúmenes</h3>\n<p>Por defecto, los contenedores no conservarán nuestros datos. Cuando cierres el contenedor de la base datos, <i>es posible</i> que no puedas recuperar los datos.</p>\n<blockquote>\n<p>Mongo, de hecho, es un caso raro en el que el contenedor conserva los datos. Esto sucede, ya que los desarrolladores que crearon la imagen de Docker para Mongo han definido un volumen para usar. <a href=\"https://github.com/docker-library/mongo/blob/cb8a419053858e510fc68ed2d69415b3e50011cb/4.4/Dockerfile#L113\">Esta línea</a> en el Dockerfile indicará a Docker que conserve los datos en un volumen.</p>\n</blockquote>\n<p>Hay dos métodos distintos para almacenar los datos:</p>\n<ul>\n<li>Declarar una ubicación en tu sistema de archivos (llamado <a href=\"https://docs.docker.com/storage/bind-mounts/\">bind mount</a> (montaje de enlace))</li>\n<li>Dejar que Docker decida dónde almacenar los datos (<a href=\"https://docs.docker.com/storage/volumes/\">volumen</a>)</li>\n</ul>\n<p>La primera opción es preferible en la mayoría de los casos siempre que uno <i>realmente</i> necesite evitar eliminar los datos.</p>\n<p>Veamos ambos en acción con docker-compose. Comencemos con <i>bind mount</i>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> ./mongo_data<span class=\"token punctuation\">:</span>/data/db</span></code></pre></div>\n<p>Esto creará un directorio llamado <em>mongo_data</em> en tu sistema de archivos local y lo asignará al contenedor como <em>/data/db</em>. Esto significa que los datos en <em>/data/db</em> se almacenan fuera del contenedor, ¡pero el contenedor aún puede acceder a ellos! Solo recuerda agregar el directorio a .gitignore.</p>\n<p>Se puede lograr un resultado similar con un volumen con nombre:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n      <span class=\"token punctuation\">-</span> mongo_data<span class=\"token punctuation\">:</span>/data/db\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">mongo_data</span><span class=\"token punctuation\">:</span></span></code></pre></div>\n<p>Ahora, el volumen es creado y controlado por Docker. Después de iniciar la aplicación (<em>docker compose -f docker-compose.dev.yml up</em>) puedes enumerar los volúmenes con <em>docker volume ls</em>, inspeccionar uno de ellos con <em>docker volume inspect</em> e incluso eliminarlos con <em>docker volume rm</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> volume <span class=\"token function\">ls</span>\nDRIVER    VOLUME NAME\n<span class=\"token builtin class-name\">local</span>     todo-backend_mongo_data\n$ <span class=\"token function\">docker</span> volume inspect todo-backend_mongo_data\n<span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"CreatedAt\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"2024-19-03T12:52:11Z\"</span>,\n        <span class=\"token string\">\"Driver\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"local\"</span>,\n        <span class=\"token string\">\"Labels\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"com.docker.compose.project\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"todo-backend\"</span>,\n            <span class=\"token string\">\"com.docker.compose.version\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"1.29.2\"</span>,\n            <span class=\"token string\">\"com.docker.compose.volume\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"mongo_data\"</span>\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">\"Mountpoint\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"/var/lib/docker/volumes/todo-backend_mongo_data/_data\"</span>,\n        <span class=\"token string\">\"Name\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"todo-backend_mongo_data\"</span>,\n        <span class=\"token string\">\"Options\"</span><span class=\"token builtin class-name\">:</span> null,\n        <span class=\"token string\">\"Scope\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"local\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>El volumen con nombre aún está almacenado en tu sistema de archivos local, pero descubrir <i>dónde</i> puede no ser tan trivial como con la opción anterior.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.7.</h3>\n<h4>Ejercicio 12.7: Escribiendo un poco de código de MongoDB</h4>\n<p>Ten en cuenta que este ejercicio asume que has realizado todas las configuraciones realizadas en el material después del ejercicio 12.5. Aún debes ejecutar el backend de la aplicación de tareas <i>fuera de un contenedor</i>, solo MongoDB está en un contenedor por ahora.</p>\n<p>La aplicación de tareas no tiene una implementación adecuada de las rutas para obtener una tarea pendiente (GET <i>/todos/:id</i>) y actualizar una tarea pendiente (PUT <i>/todos/:id</i>). Arregla el código.</p>\n</div>\n<div class=\"content\">\n<h3>Depurando problemas en contenedores</h3>\n<blockquote>\n<p><i>Cuando codificas, lo más probable es que termines en una situación en la que todo está roto.</i></p>\n</blockquote>\n<blockquote>\n<p>- Matti Luukkainen</p>\n</blockquote>\n<p>Al desarrollar con contenedores, necesitamos aprender nuevas herramientas para la depuración, ya que no podemos simplemente usar \"console.log\" para todo. Cuando el código tiene un error, a menudo puede estar en un estado en el que al menos algo funciona y podemos avanzar a partir de ahí. La configuración suele estar en cualquiera de los dos estados: 1. funcionando o 2. rota. Repasaremos algunas herramientas que pueden ayudar cuando tu aplicación se encuentra en este último estado.</p>\n<p>Al desarrollar software, puedes avanzar paso a paso con seguridad, verificando todo el tiempo que lo que has codificado se comporta como se espera. A menudo, este no es el caso cuando se realizan configuraciones. La configuración que puedes estar escribiendo puede romperse hasta en el momento en que finaliza. Entonces, cuando escribes un docker-compose.yml o Dockerfile largo y no funciona, debes tomarte un momento y pensar en las diversas formas en que podrías confirmar que algo funciona.</p>\n<p><i>Cuestionar todo</i> sigue siendo aplicable aquí. Como se dijo en la <a href=\"/es/part3/guardando_datos_en_mongo_db\">parte 3</a>: La clave es ser sistemático. Dado que el problema puede existir en cualquier lugar, <i>debes cuestionar todo</i> y eliminar todas las posibles fuentes de error una por una.</p>\n<p>Para mí, el método más valioso de depuración es detenerme y pensar en lo que estoy tratando de lograr en lugar de simplemente golpearme la cabeza con el problema. A menudo hay una solución simple, alternativa, o una búsqueda rápida en Google que me ayudará a seguir adelante.</p>\n<h4>exec</h4>\n<p>El comando de Docker <a href=\"https://docs.docker.com/engine/reference/commandline/exec/\">exec</a> es un gran bateador. Se puede usar para saltar directamente a un contenedor cuando se está ejecutando.</p>\n<p>Iniciemos un servidor web en segundo plano y hagamos un poco de depuración para que funcione y muestre el mensaje \"¡Hola, exec!\" en nuestro navegador. Elijamos <a href=\"https://www.nginx.com/\">Nginx</a> que es, entre otras cosas, un servidor capaz de servir archivos HTML estáticos. Tiene un index.html predeterminado que podemos reemplazar.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-d</span> nginx</code></pre></div>\n<p>Bien, ahora las preguntas son:</p>\n<ul>\n<li>¿Dónde debemos ir con nuestro navegador?</li>\n<li>¿Está incluso funcionando?</li>\n</ul>\n<p>Sabemos cómo responder a lo último: enumerando los contenedores en ejecución.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE           COMMAND                  CREATED              STATUS                      PORTS     NAMES\n3f831a57b7cc   nginx           <span class=\"token string\">\"/docker-entrypoint.…\"</span>   About a minute ago   Up About a minute           <span class=\"token number\">80</span>/tcp    keen_darwin</code></pre></div>\n<p>¡Sí! También hemos respondido a la primera pregunta. Parece escuchar en el puerto 80, como se ve en la salida anterior.</p>\n<p>Apaguémoslo y reiniciemos con el indicador <em>-p</em> para que nuestro navegador acceda a él.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container stop keen_darwin\n$ <span class=\"token function\">docker</span> container <span class=\"token function\">rm</span> keen_darwin\n\n$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:80 nginx</code></pre></div>\n<blockquote>\n<p><i><strong>Nota del editor:</strong> al desarrollar, es <strong>esencial</strong> seguir constantemente los logs del contenedor. Normalmente no ejecuto contenedores en modo detached (es decir, con -d) ya que requiere un poco de esfuerzo adicional abrir los logs.</p>\n<p>Cuando estoy 100% seguro de que todo funciona... no, cuando estoy 200% seguro, entonces puedo relajarme un poco e iniciar los contenedores en modo detached. Hasta que todo vuelva a desmoronarse y sea hora de abrir los logs nuevamente.</i></p>\n</blockquote>\n<p>Miremos a la aplicación en <a href=\"http://localhost:8080\">http://localhost:8080</a>. ¡Parece que muestra un mensaje incorrecto! Saltemos directamente al contenedor y arreglémoslo. Mantén tu navegador abierto, no necesitaremos cerrar el contenedor para esta corrección. Ejecutaremos bash dentro del contenedor, las banderas <em>-it</em> asegurarán que podamos interactuar con el contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                                   NAMES\n7edcb36aff08   nginx     <span class=\"token string\">\"/docker-entrypoint.…\"</span>   About a minute ago   Up About a minute   <span class=\"token number\">0.0</span>.0.0:8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp, :::8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp   wonderful_ramanujan\n\n$ <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> wonderful_ramanujan <span class=\"token function\">bash</span>\nroot@7edcb36aff08:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Ahora que estamos dentro, necesitamos encontrar el archivo defectuoso y reemplazarlo. Rapidamente Google nos dice que el archivo en sí es <em>/usr/share/nginx/html/index.html</em>.</p>\n<p>Pasemos al directorio y eliminemos el archivo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@7edcb36aff08:/<span class=\"token comment\"># cd /usr/share/nginx/html/</span>\nroot@7edcb36aff08:/<span class=\"token comment\"># rm index.html</span></code></pre></div>\n<p>Ahora, si vamos a <a href=\"http://localhost:8080/\">http://localhost:8080/</a> sabemos que eliminamos el archivo correcto. La página muestra 404. Vamos a reemplazarlo con uno que contenga el contenido correcto:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@7edcb36aff08:/<span class=\"token comment\"># echo \"Hello, exec!\" > index.html</span></code></pre></div>\n<p>¡Actualiza la página y se mostrará nuestro mensaje! Ahora sabemos cómo se puede usar exec para interactuar con los contenedores. Recuerda que todos los cambios se pierden cuando se elimina el contenedor. Para conservar los cambios, debes usar <em>commit</em> tal como lo hicimos en la <a href=\"/es/part12/introduccion_a_los_contenedores#otros-comandos-de-docker\">sección anterior</a>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.8.</h3>\n<h4>Ejercicio 12.8: Interfaz de linea de comandos (CLI) de Mongo</h4>\n<blockquote>\n<p>Usa <em>script</em> para registrar lo que haces, guarda el archivo en script-answers/exercise12_8.txt</p>\n</blockquote>\n<p>Mientras se ejecuta MongoDB del ejercicio anterior, accede a la base de datos con la interfaz de línea de comandos (CLI) de mongo. Puedes hacerlo usando docker exec. A continuación, agrega una tarea nueva mediante la CLI.</p>\n<p>El comando para abrir CLI cuando estás dentro del contenedor es <em>mongosh</em></p>\n<p>La CLI de mongo requerirá las banderas de nombre de usuario y contraseña para autenticarse correctamente. Las banderas <em>-u root -p example</em> deberían funcionar, los valores corresponden a los que se encuentran en el archivo <em>docker-compose.dev.yml</em>.</p>\n<ul>\n<li>Paso 1: Ejecuta MongoDB</li>\n<li>Paso 2: Utiliza <i>docker exec</i> para ingresar al contenedor</li>\n<li>Paso 3: Abre Mongo CLI</li>\n</ul>\n<p>Cuando te hayas conectado a Mongo CLI, puedes pedirle que muestre las DBs dentro:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> show dbs\nadmin         <span class=\"token number\">0</span>.000GB\nconfig         <span class=\"token number\">0</span>.000GB\n<span class=\"token builtin class-name\">local</span>         <span class=\"token number\">0</span>.000GB\nthe_database  <span class=\"token number\">0</span>.000GB</code></pre></div>\n<p>Para acceder a la base de datos correcta:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> use the_database</code></pre></div>\n<p>Y finalmente para conocer las colecciones:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> show collections\ntodos</code></pre></div>\n<p>Ahora podemos acceder a los datos en esas colecciones:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> db.todos.find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    _id: ObjectId<span class=\"token punctuation\">(</span><span class=\"token string\">\"633c270ba211aa5f7931f078\"</span><span class=\"token punctuation\">)</span>,\n    text: <span class=\"token string\">'Write code'</span>,\n    done: <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>,\n  <span class=\"token punctuation\">{</span>\n    _id: ObjectId<span class=\"token punctuation\">(</span><span class=\"token string\">\"633c270ba211aa5f7931f079\"</span><span class=\"token punctuation\">)</span>,\n    text: <span class=\"token string\">'Learn about containers'</span>,\n    done: <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Inserta una tarea pendiente nueva con el texto: \"Increase the number of tools in my tool belt\" con el estado done como false. Consulta la <a href=\"https://www.mongodb.com/docs/manual/reference/method/db.collection.insertOne/\">documentación</a> para ver cómo se realiza la adición.</p>\n<p>Asegúrate de ver la nueva tarea tanto en la aplicación Express como al consultar desde la CLI de Mongo.</p>\n</div>\n<div class=\"content\">\n<h3>Redis</h3>\n<p><a href=\"https://redis.io/\">Redis</a> es una base de datos <a href=\"https://redis.com/nosql/key-value-databases/\">clave-valor</a>. En contraste con por ej. MongoDB, los datos almacenados en un almacén de clave-valor tienen un poco menos de estructura, por ejemplo, no contienen colecciones ni tablas, solo contienen pedazos de datos que se pueden obtener en función de la <i>clave</i> que se adjuntó a los datos (el <i>valor</i>).</p>\n<p>De forma predeterminada, Redis funciona <i>en memoria</i>, lo que significa que no almacena datos de forma persistente.</p>\n<p>Un caso de uso excelente para Redis es usarlo como <i>caché</i>. Los cachés a menudo se usan para almacenar datos que, de otro modo, serían lentos para obtener y guardar hasta que ya no sean válidos. Después de que la memoria caché se vuelva inválida, obtendrás los datos nuevamente y los almacenarás en la memoria caché.</p>\n<p>Redis no tiene nada que ver con los contenedores. Pero dado que ya podemos agregar <i>cualquier</i> servicio de terceros a tus aplicaciones, ¿por qué no conocer uno nuevo?</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.9. - 12.11.</h3>\n<h4>Ejercicio 12.9: Instalando Redis en el proyecto</h4>\n<p>El servidor Express ya se configuró para usar Redis y solo falta la variable de entorno <em>REDIS_URL</em>. La aplicación utilizará esa variable de entorno para conectarse a Redis. Lee la <a href=\"https://hub.docker.com/_/redis\">página de Docker Hub para Redis</a>, agrega Redis a <i>todo-app/todo-backend/docker-compose.dev.yml&#x3C;/ i> definiendo otro servicio después de mongo:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span></code></pre></div>\n<p>Dado que la página de Docker Hub no tiene toda la información, podemos usar Google para ayudarnos. El puerto predeterminado para Redis se encuentra fácilmente al buscarlo:</p>\n<picture><img src=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png\" alt=\"resultado de busqueda de google para &#x22;default port for redis&#x22; es 6379\" srcset=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/772e8/redis_port_by_google.png 200w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/e17e5/redis_port_by_google.png 400w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png 800w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/f96df/redis_port_by_google.png 849w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>No sabremos si la configuración funciona a menos que la probemos. La aplicación no comenzará a usar Redis por sí sola, eso sucederá en el próximo ejercicio.</p>\n<p>Una vez que Redis esté configurado e iniciado, reinicia el backend y asígnale el <i>REDIS_URL</i>, que tiene la forma <i>redis://host:port</i></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">REDIS_URL</span><span class=\"token operator\">=</span>insert-redis-url-here <span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://the_username:the_password@localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Ahora puedes probar la configuración agregando la línea</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> redis <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../redis'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>al servidor Express, por ejemplo, en el archivo <i>routes/index.js</i>. Si no pasa nada, la configuración se hizo correctamente. Si no, el servidor falla:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">events.js:291\n      throw er<span class=\"token punctuation\">;</span> // Unhandled <span class=\"token string\">'error'</span> event\n      ^\n\nError: Redis connection to localhost:637 failed - connect ECONNREFUSED <span class=\"token number\">127.0</span>.0.1:6379\n    at TCPConnectWrap.afterConnect <span class=\"token punctuation\">[</span>as oncomplete<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>net.js:1144:16<span class=\"token punctuation\">)</span>\nEmitted <span class=\"token string\">'error'</span> event on RedisClient instance at:\n    at RedisClient.on_error <span class=\"token punctuation\">(</span>/Users/mluukkai/opetus/docker-fs/container-app/express-app/node_modules/redis/index.js:342:14<span class=\"token punctuation\">)</span>\n    at Socket.<span class=\"token operator\">&lt;</span>anonymous<span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>/Users/mluukkai/opetus/docker-fs/container-app/express-app/node_modules/redis/index.js:223:14<span class=\"token punctuation\">)</span>\n    at Socket.emit <span class=\"token punctuation\">(</span>events.js:314:20<span class=\"token punctuation\">)</span>\n    at emitErrorNT <span class=\"token punctuation\">(</span>internal/streams/destroy.js:100:8<span class=\"token punctuation\">)</span>\n    at emitErrorCloseNT <span class=\"token punctuation\">(</span>internal/streams/destroy.js:68:3<span class=\"token punctuation\">)</span>\n    at processTicksAndRejections <span class=\"token punctuation\">(</span>internal/process/task_queues.js:80:21<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  errno: -61,\n  code: <span class=\"token string\">'ECONNREFUSED'</span>,\n  syscall: <span class=\"token string\">'connect'</span>,\n  address: <span class=\"token string\">'127.0.0.1'</span>,\n  port: <span class=\"token number\">6379</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> app crashed - waiting <span class=\"token keyword\">for</span> <span class=\"token function\">file</span> changes before starting<span class=\"token punctuation\">..</span>.</code></pre></div>\n<h4>Ejercicio 12.10:</h4>\n<p>El proyecto ya tiene <a href=\"https://www.npmjs.com/package/redis\">https://www.npmjs.com/package/redis</a> instalado y dos funciones \"promisificadas\": getAsync y setAsync.</p>\n<ul>\n<li>La función setAsync toma la clave y el valor, usando la clave para almacenar el valor.</li>\n<li>La función getAsync toma la clave y devuelve el valor en una promesa.</li>\n</ul>\n<p>Implementa un contador de tareas pendientes que guarde la cantidad de tareas pendientes creadas en Redis:</p>\n<ul>\n<li>Paso 1: Cada vez que se envíe una solicitud para agregar una tarea pendiente, incrementa el contador en uno.</li>\n<li>Paso 2: Crea un endpoint GET/statistics donde puedas solicitar los metadatos de uso. El formato debe ser el siguiente JSON:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"added_todos\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Ejercicio 12.11:</h4>\n<blockquote>\n<p>Utiliza <em>script</em> para registrar lo que haces, guarda el archivo como script-answers/exercise12_11.txt</p>\n</blockquote>\n<p>Si la aplicación no se comporta como se esperaba, un acceso directo a la base de datos puede ser beneficioso para identificar problemas. Probemos cómo se puede usar <a href=\"https://redis.io/topics/rediscli\">redis-cli</a> para acceder a la base de datos.</p>\n<ul>\n<li>Ve al contenedor de redis con <em>docker exec</em> y abre redis-cli.</li>\n<li>Encuentra la clave que usaste con <em><a href=\"https://redis.io/commands/keys\">KEYS *</a></em></li>\n<li>Verifica el valor de la clave con el comando <a href=\"https://redis.io/commands/get\">GET</a></li>\n<li>Establece el valor del contador en 9001, encuentra el comando correcto <a href=\"https://redis.io/commands/\">aquí</a></li>\n<li>Asegúrate de que el nuevo valor funcione actualizando la página <a href=\"http://localhost:3000/statistics\">http://localhost:3000/statistics</a></li>\n<li>Crea una nueva tarea con Postman y asegúrate de que el contador haya aumentado en consecuencia desde redis-cli</li>\n<li>Elimina la clave de cli y asegúrate de que el contador funcione cuando se agreguen nuevas tareas</li>\n</ul>\n</div>\n<div class=\"content\">\n<h3>Persistiendo datos con Redis</h3>\n<p>En la sección anterior, se mencionó que <i>por defecto</i> Redis no conserva los datos. Sin embargo, la persistencia es fácil de activar. Solo necesitamos iniciar Redis con un comando diferente, como se indica en la <a href=\"https://hub.docker.com/_/redis\">página de Docker hub</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Everything else</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'redis-server'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'--appendonly'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'yes'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># Overwrite the CMD</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># Declare the volume</span>\n      <span class=\"token punctuation\">-</span> ./redis_data<span class=\"token punctuation\">:</span>/data</code></pre></div>\n<p>Los datos ahora se almacenarán en el directorio <i>redis_data</i> de la máquina host.\n¡Recuerda agregar el directorio a .gitignore!</p>\n<h4>Otras funcionalidades de Redis</h4>\n<p>Además de las operaciones GET, SET y DEL en claves y valores, Redis también puede hacer mucho más. Por ejemplo, puede hacer que las claves caduquen automáticamente, lo que es una característica muy útil cuando Redis se usa como caché.</p>\n<p>Redis también se puede utilizar para implementar el patrón denominado <a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">publish-subscribe</a> (o PubSub), que es un mecanismo de comunicación asíncrona para aplicaciones distribuidas. En este escenario, Redis funciona como un <i>agente de mensajes</i> entre dos o más aplicaciones. Algunas de las aplicaciones están <i>publicando</i> mensajes enviándolos a Redis, que al recibir un mensaje, informa a las partes que se han <i>suscrito</i> a esos mensajes.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.12.</h3>\n<h4>Ejercicio 12.12: Persistiendo datos en Redis</h4>\n<p>Comprueba que los datos no se conservan de forma predeterminada, después de ejecutar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml down\n<span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up</code></pre></div>\n<p> el valor del contador se restablece a 0.</p>\n<p>Luego, crea un volumen para los datos de Redis (modificando <i>todo-app/todo-backend/docker-compose.dev.yml</i>) y asegúrate de que los datos sobrevivan después de ejecutar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml down\n<span class=\"token function\">docker</span> compose <span class=\"token parameter variable\">-f</span> docker-compose.dev.yml up</code></pre></div>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"b","lang":"es"}}},"pageContext":{"part":12,"letter":"b","lang":"es"}},"staticQueryHashes":["3128451518"]}